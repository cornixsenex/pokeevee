include/constants/maps.h:// Warps using this map will instead use the warp data stored in gSaveBlock1Ptr->dynamicWarp.
include/constants/contest.h:// IDs below - 1 are indexes into gSaveBlock1Ptr->contestWinners[]
include/constants/tv.h:// The first 5 elements of gSaveBlock1Ptr->tvShows are reserved
src/braille_puzzles.c:     && (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(SEALED_CHAMBER_OUTER_ROOM)
src/braille_puzzles.c:     && gSaveBlock1Ptr->location.mapNum == MAP_NUM(SEALED_CHAMBER_OUTER_ROOM)))
src/braille_puzzles.c:        if (gSaveBlock1Ptr->pos.x == 10 && gSaveBlock1Ptr->pos.y == 3)
src/braille_puzzles.c:        if (gSaveBlock1Ptr->pos.x == 9 && gSaveBlock1Ptr->pos.y == 3)
src/braille_puzzles.c:        if (gSaveBlock1Ptr->pos.x == 11 && gSaveBlock1Ptr->pos.y == 3)
src/braille_puzzles.c:        && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(DESERT_RUINS)
src/braille_puzzles.c:        && gSaveBlock1Ptr->location.mapNum == MAP_NUM(DESERT_RUINS))
src/braille_puzzles.c:        if (gSaveBlock1Ptr->pos.x == 6 && gSaveBlock1Ptr->pos.y == 23)
src/braille_puzzles.c:        else if (gSaveBlock1Ptr->pos.x == 5 && gSaveBlock1Ptr->pos.y == 23)
src/braille_puzzles.c:        else if (gSaveBlock1Ptr->pos.x == 7 && gSaveBlock1Ptr->pos.y == 23)
src/braille_puzzles.c:    if (!FlagGet(FLAG_SYS_REGISTEEL_PUZZLE_COMPLETED) && (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ANCIENT_TOMB) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ANCIENT_TOMB)))
src/braille_puzzles.c:        if (gSaveBlock1Ptr->pos.x == 8 && gSaveBlock1Ptr->pos.y == 25)
src/braille_puzzles.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ISLAND_CAVE)
src/braille_puzzles.c:        && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ISLAND_CAVE))
src/braille_puzzles.c:            if (gSaveBlock1Ptr->pos.x == xPos && gSaveBlock1Ptr->pos.y == yPos)
src/braille_puzzles.c:                if (gSaveBlock1Ptr->pos.x == 8 && gSaveBlock1Ptr->pos.y == 21)
src/event_data.c:    memset(gSaveBlock1Ptr->flags, 0, sizeof(gSaveBlock1Ptr->flags));
src/event_data.c:    memset(gSaveBlock1Ptr->vars, 0, sizeof(gSaveBlock1Ptr->vars));
src/event_data.c:    memset(&gSaveBlock1Ptr->flags[TEMP_FLAGS_START / 8], 0, TEMP_FLAGS_SIZE);
src/event_data.c:    memset(&gSaveBlock1Ptr->vars[TEMP_VARS_START - VARS_START], 0, TEMP_VARS_SIZE);
src/event_data.c:    memset(&gSaveBlock1Ptr->flags[DAILY_FLAGS_START / 8], 0, DAILY_FLAGS_SIZE);
src/event_data.c:        return &gSaveBlock1Ptr->vars[id - VARS_START];
src/event_data.c:        return &gSaveBlock1Ptr->flags[id / 8];
src/battle_tent.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/battle_tent.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/battle_tent.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/union_room_player_avatar.c:    TrySpawnObjectEvent(sUnionRoomLocalIds[leaderId], gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/union_room_player_avatar.c:    RemoveObjectEventByLocalIdAndMap(sUnionRoomLocalIds[leaderId], gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/union_room_player_avatar.c:    if (TryGetObjectEventIdByLocalIdAndMap(sUnionRoomLocalIds[leaderId], gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objectId))
src/union_room_player_avatar.c:    if (TryGetObjectEventIdByLocalIdAndMap(sUnionRoomLocalIds[leaderId], gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objectId))
src/trainer_card.c:    trainerCard->money = GetMoney(&gSaveBlock1Ptr->money);
src/trainer_card.c:        trainerCard->easyChatProfile[i] = gSaveBlock1Ptr->easyChatProfile[i];
src/roamer.c:#define ROAMER(index) (&gSaveBlock1Ptr->roamer[index])
src/roamer.c:        sLocationHistory[i][0][MAP_GRP] = gSaveBlock1Ptr->location.mapGroup;
src/roamer.c:        sLocationHistory[i][0][MAP_NUM] = gSaveBlock1Ptr->location.mapNum;
src/roamer.c:        if (IsRoamerAt(i, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum) == TRUE && (Random() % 4) == 0)
src/tv.c:    for (i = 0; i < ARRAY_COUNT(gSaveBlock1Ptr->tvShows); i++)
src/tv.c:        gSaveBlock1Ptr->tvShows[i].commonInit.kind = 0;
src/tv.c:        gSaveBlock1Ptr->tvShows[i].commonInit.active = 0;
src/tv.c:        for (j = 0; j < ARRAY_COUNT(gSaveBlock1Ptr->tvShows[i].commonInit.data); j++)
src/tv.c:            gSaveBlock1Ptr->tvShows[i].commonInit.data[j] = 0;
src/tv.c:        if (gSaveBlock1Ptr->tvShows[i].common.kind == TVSHOW_OFF_AIR)
src/tv.c:        if (GetTVGroupByShowId(gSaveBlock1Ptr->tvShows[j].common.kind) != TVGROUP_OUTBREAK)
src/tv.c:            if (gSaveBlock1Ptr->tvShows[j].common.active == TRUE)
src/tv.c:            show = &gSaveBlock1Ptr->tvShows[j];
src/tv.c:            j = ARRAY_COUNT(gSaveBlock1Ptr->tvShows) - 2;
src/tv.c:    if (gSaveBlock1Ptr->outbreakPokemonSpecies != SPECIES_NONE
src/tv.c:     && gSaveBlock1Ptr->tvShows[slot].common.kind == TVSHOW_MASS_OUTBREAK)
src/tv.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(LILYCOVE_CITY_COVE_LILY_MOTEL_1F)
src/tv.c:         && gSaveBlock1Ptr->location.mapNum == MAP_NUM(LILYCOVE_CITY_COVE_LILY_MOTEL_1F))
src/tv.c:    return gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004].common.kind;
src/tv.c:    for (i = 0; i < ARRAY_COUNT(gSaveBlock1Ptr->tvShows) - 1; i++)
src/tv.c:        if (gSaveBlock1Ptr->tvShows[i].common.kind != TVSHOW_OFF_AIR
src/tv.c:         && gSaveBlock1Ptr->tvShows[i].common.kind != TVSHOW_MASS_OUTBREAK
src/tv.c:         && gSaveBlock1Ptr->tvShows[i].common.active == TRUE)
src/tv.c:    tvShow = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    if (tvShow->common.kind == TVSHOW_MASS_OUTBREAK && gSaveBlock1Ptr->outbreakPokemonSpecies != SPECIES_NONE)
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mon1 = SPECIES_NONE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mon2 = SPECIES_NONE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.lastMove = MOVE_NONE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.quote[0] = -1;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.onAir = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.valA_5 = 0;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn2 = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon2 = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem2 = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall2 = FALSE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.valB_4 = 0;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mapnum = 0;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.battleNum = 0;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mon1 = gBattleResults.playerMon1Species;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mon2 = gBattleResults.playerMon2Species;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.lastMove = gBattleResults.lastUsedMovePlayer;
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.battleNum != 0xFF)
src/tv.c:        gSaveBlock1Ptr->gabbyAndTyData.battleNum++;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn = gBattleResults.playerMonWasDamaged;
src/tv.c:        gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon = TRUE;
src/tv.c:        gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon = FALSE;
src/tv.c:        gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem = TRUE;
src/tv.c:        gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem = FALSE;
src/tv.c:            gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall = TRUE;
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.lastMove == MOVE_NONE)
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn2 = gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon2 = gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem2 = gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall2 = gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.onAir = TRUE;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.mapnum = gMapHeader.regionMapSectionId;
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.onAir = FALSE;
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.battleNum > 5)
src/tv.c:        return (gSaveBlock1Ptr->gabbyAndTyData.battleNum % 3) + 6;
src/tv.c:    return gSaveBlock1Ptr->gabbyAndTyData.battleNum;
src/tv.c:    return gSaveBlock1Ptr->gabbyAndTyData.onAir;
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.quote[0] == EC_EMPTY_WORD)
src/tv.c:    CopyEasyChatWord(gStringVar1, gSaveBlock1Ptr->gabbyAndTyData.quote[0]);
src/tv.c:    gSaveBlock1Ptr->gabbyAndTyData.quote[0] = -1;
src/tv.c:    if (!gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn2)
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall2)
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem2)
src/tv.c:    if (gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon2)
src/tv.c:            sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:                    show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:            sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:                show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:        show2 = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:            show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8006];
src/tv.c:    if (show->fanClubSpecial.language == LANGUAGE_JAPANESE || gSaveBlock1Ptr->linkBattleRecords.languages[0] == LANGUAGE_JAPANESE)
src/tv.c:        show->fanClubSpecial.idolNameLanguage = gSaveBlock1Ptr->linkBattleRecords.languages[0];
src/tv.c:    DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:        show2 = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    if (!(gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(TRAINER_HILL_ENTRANCE) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(TRAINER_HILL_ENTRANCE))
src/tv.c:     && !(gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(BATTLE_FRONTIER_MART) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(BATTLE_FRONTIER_MART))
src/tv.c:        sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:                show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:            show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonSpecies = show->massOutbreak.species;
src/tv.c:    gSaveBlock1Ptr->outbreakLocationMapNum = show->massOutbreak.locationMapNum;
src/tv.c:    gSaveBlock1Ptr->outbreakLocationMapGroup = show->massOutbreak.locationMapGroup;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonLevel = show->massOutbreak.level;
src/tv.c:    gSaveBlock1Ptr->outbreakUnused1 = show->massOutbreak.unused1;
src/tv.c:    gSaveBlock1Ptr->outbreakUnused2 = show->massOutbreak.unused2;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[0] = show->massOutbreak.moves[0];
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[1] = show->massOutbreak.moves[1];
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[2] = show->massOutbreak.moves[2];
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[3] = show->massOutbreak.moves[3];
src/tv.c:    gSaveBlock1Ptr->outbreakUnused3 = show->massOutbreak.unused3;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonProbability = show->massOutbreak.probability;
src/tv.c:    gSaveBlock1Ptr->outbreakDaysLeft = 2;
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:            if (gSaveBlock1Ptr->tvShows[i].common.kind == TVSHOW_MASS_OUTBREAK)
src/tv.c:            sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:                show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonSpecies = SPECIES_NONE;
src/tv.c:    gSaveBlock1Ptr->outbreakLocationMapNum = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakLocationMapGroup = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonLevel = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakUnused1 = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakUnused2 = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[0] = MOVE_NONE;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[1] = MOVE_NONE;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[2] = MOVE_NONE;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonMoves[3] = MOVE_NONE;
src/tv.c:    gSaveBlock1Ptr->outbreakUnused3 = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakPokemonProbability = 0;
src/tv.c:    gSaveBlock1Ptr->outbreakDaysLeft = 0;
src/tv.c:    if (gSaveBlock1Ptr->outbreakPokemonSpecies == SPECIES_NONE)
src/tv.c:            if (gSaveBlock1Ptr->tvShows[i].massOutbreak.kind == TVSHOW_MASS_OUTBREAK && gSaveBlock1Ptr->tvShows[i].massOutbreak.active == TRUE)
src/tv.c:                show = &gSaveBlock1Ptr->tvShows[i];
src/tv.c:    if (gSaveBlock1Ptr->outbreakDaysLeft <= days)
src/tv.c:        gSaveBlock1Ptr->outbreakDaysLeft -= days;
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[LAST_TVSHOW_IDX];
src/tv.c:        sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:            show2 = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:            DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, LAST_TVSHOW_IDX);
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:        decoration = gSaveBlock1Ptr->secretBases[0].decorations[i];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:        show->trainerFanClub.words[0] = gSaveBlock1Ptr->easyChatProfile[0];
src/tv.c:        show->trainerFanClub.words[1] = gSaveBlock1Ptr->easyChatProfile[1];
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    if (gSaveBlock1Ptr->linkBattleRecords.entries[0].name[0] == EOS)
src/tv.c:        shows = gSaveBlock1Ptr->tvShows;
src/tv.c:                DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, showIdx);
src/tv.c:                CompactTVShowArray(gSaveBlock1Ptr->tvShows);
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:            show->frontier.species1 = GetMonData(&gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[0] - 1], MON_DATA_SPECIES, NULL);
src/tv.c:            show->frontier.species2 = GetMonData(&gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[1] - 1], MON_DATA_SPECIES, NULL);
src/tv.c:        sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:            show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:            if (show->secretBaseSecrets.language == LANGUAGE_JAPANESE || gSaveBlock1Ptr->secretBases[VarGet(VAR_CURRENT_SECRET_BASE)].language == LANGUAGE_JAPANESE)
src/tv.c:                show->secretBaseSecrets.baseOwnersNameLanguage = gSaveBlock1Ptr->secretBases[VarGet(VAR_CURRENT_SECRET_BASE)].language;
src/tv.c:    sCurTVShowSlot = FindFirstEmptyRecordMixTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        show = &gSaveBlock1Ptr->tvShows[sCurTVShowSlot];
src/tv.c:        sCurTVShowSlot = GetFirstEmptyPokeNewsSlot(gSaveBlock1Ptr->pokeNews);
src/tv.c:                gSaveBlock1Ptr->pokeNews[sCurTVShowSlot].kind = newsKind;
src/tv.c:                gSaveBlock1Ptr->pokeNews[sCurTVShowSlot].dayCountdown = POKENEWS_COUNTDOWN;
src/tv.c:                gSaveBlock1Ptr->pokeNews[sCurTVShowSlot].state = POKENEWS_STATE_UPCOMING;
src/tv.c:    gSaveBlock1Ptr->pokeNews[i].kind = POKENEWS_NONE;
src/tv.c:    gSaveBlock1Ptr->pokeNews[i].state = POKENEWS_STATE_INACTIVE;
src/tv.c:    gSaveBlock1Ptr->pokeNews[i].dayCountdown = 0;
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind == POKENEWS_NONE)
src/tv.c:                if (gSaveBlock1Ptr->pokeNews[j].kind != POKENEWS_NONE)
src/tv.c:                    gSaveBlock1Ptr->pokeNews[i] = gSaveBlock1Ptr->pokeNews[j];
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind != POKENEWS_NONE
src/tv.c:         && gSaveBlock1Ptr->pokeNews[i].state == POKENEWS_STATE_UPCOMING
src/tv.c:         && gSaveBlock1Ptr->pokeNews[i].dayCountdown < POKENEWS_COUNTDOWN - 1)
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].dayCountdown == 0)
src/tv.c:            gSaveBlock1Ptr->pokeNews[i].state = POKENEWS_STATE_ACTIVE;
src/tv.c:                ShowFieldMessage(sPokeNewsTextGroup_Ongoing[gSaveBlock1Ptr->pokeNews[i].kind]);
src/tv.c:                ShowFieldMessage(sPokeNewsTextGroup_Ending[gSaveBlock1Ptr->pokeNews[i].kind]);
src/tv.c:            u16 dayCountdown = gSaveBlock1Ptr->pokeNews[i].dayCountdown;
src/tv.c:            gSaveBlock1Ptr->pokeNews[i].state = POKENEWS_STATE_INACTIVE;
src/tv.c:            ShowFieldMessage(sPokeNewsTextGroup_Upcoming[gSaveBlock1Ptr->pokeNews[i].kind]);
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind == newsKind)
src/tv.c:            if (gSaveBlock1Ptr->pokeNews[i].state == POKENEWS_STATE_ACTIVE && ShouldApplyPokeNewsEffect(newsKind))
src/tv.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(SLATEPORT_CITY)
src/tv.c:         && gSaveBlock1Ptr->location.mapNum == MAP_NUM(SLATEPORT_CITY)
src/tv.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(LILYCOVE_CITY_DEPARTMENT_STORE_ROOFTOP)
src/tv.c:         && gSaveBlock1Ptr->location.mapNum == MAP_NUM(LILYCOVE_CITY_DEPARTMENT_STORE_ROOFTOP))
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind == newsKind)
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind != POKENEWS_NONE)
src/tv.c:            if (gSaveBlock1Ptr->pokeNews[i].dayCountdown < days)
src/tv.c:                if (gSaveBlock1Ptr->pokeNews[i].state == POKENEWS_STATE_INACTIVE && FlagGet(FLAG_SYS_GAME_CLEAR) == TRUE)
src/tv.c:                    gSaveBlock1Ptr->pokeNews[i].state = POKENEWS_STATE_UPCOMING;
src/tv.c:                gSaveBlock1Ptr->pokeNews[i].dayCountdown -= days;
src/tv.c:    TVShow *show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    shows = gSaveBlock1Ptr->tvShows;
src/tv.c:                DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, i);
src/tv.c:                CompactTVShowArray(gSaveBlock1Ptr->tvShows);
src/tv.c:        if (gSaveBlock1Ptr->tvShows[i].common.kind == kind)
src/tv.c:            if (gSaveBlock1Ptr->tvShows[i].common.active == TRUE)
src/tv.c:                DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, i);
src/tv.c:                CompactTVShowArray(gSaveBlock1Ptr->tvShows);
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanclubLetter.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanclubLetter.words));
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].recentHappenings.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].recentHappenings.words));
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanclubOpinions.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanclubOpinions.words));
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].bravoTrainer.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].bravoTrainer.words));
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].bravoTrainerTower.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].bravoTrainerTower.words));
src/tv.c:        InitializeEasyChatWordArray(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanClubSpecial.words,
src/tv.c:                        ARRAY_COUNT(gSaveBlock1Ptr->tvShows[sCurTVShowSlot].fanClubSpecial.words));
src/tv.c:    sCurTVShowSlot = FindFirstEmptyNormalTVShowSlot(gSaveBlock1Ptr->tvShows);
src/tv.c:        if (gSaveBlock1Ptr->tvShows[i].common.kind == gSpecialVar_0x8004)
src/tv.c:    if (gSaveBlock1Ptr->location.mapGroup != MAP_GROUP(LITTLEROOT_TOWN_BRENDANS_HOUSE_1F))
src/tv.c:        if (gSaveBlock1Ptr->location.mapNum != MAP_NUM(LITTLEROOT_TOWN_BRENDANS_HOUSE_1F))
src/tv.c:        if (gSaveBlock1Ptr->location.mapNum != MAP_NUM(LITTLEROOT_TOWN_MAYS_HOUSE_1F))
src/tv.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(LITTLEROOT_TOWN_BRENDANS_HOUSE_1F))
src/tv.c:            if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(LITTLEROOT_TOWN_BRENDANS_HOUSE_1F))
src/tv.c:            if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(LITTLEROOT_TOWN_MAYS_HOUSE_1F))
src/tv.c:    RemoveObjectEventByLocalIdAndMap(LOCALID_BATTLE_TOWER_LOBBY_REPORTER, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/tv.c:            SetMixedTVShows(gSaveBlock1Ptr->tvShows, (*rmBuffer)[1], (*rmBuffer)[2], (*rmBuffer)[3]);
src/tv.c:            SetMixedTVShows((*rmBuffer)[0], gSaveBlock1Ptr->tvShows, (*rmBuffer)[2], (*rmBuffer)[3]);
src/tv.c:            SetMixedTVShows((*rmBuffer)[0], (*rmBuffer)[1], gSaveBlock1Ptr->tvShows, (*rmBuffer)[3]);
src/tv.c:            SetMixedTVShows((*rmBuffer)[0], (*rmBuffer)[1], (*rmBuffer)[2], gSaveBlock1Ptr->tvShows);
src/tv.c:        CompactTVShowArray(gSaveBlock1Ptr->tvShows);
src/tv.c:        CompactTVShowArray(gSaveBlock1Ptr->tvShows);
src/tv.c:        switch (gSaveBlock1Ptr->tvShows[i].common.kind)
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->contestLiveUpdates.winningSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->contestLiveUpdates.losingSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->battleUpdate.speciesPlayer;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->battleUpdate.speciesOpponent;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->fanclubLetter.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->fanclubOpinions.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->dummy.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->nameRaterShow.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->nameRaterShow.randomSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->bravoTrainer.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->bravoTrainerTower.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->bravoTrainerTower.defeatedSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->pokemonToday.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->pokemonTodayFailed.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->pokemonTodayFailed.species2;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->pokemonAngler.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->worldOfMasters.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->worldOfMasters.caughtPoke;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->breakingNews.lastOpponentSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->breakingNews.poke1Species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->secretBaseVisit.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->battleSeminar.species;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->battleSeminar.foeSpecies;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->frontier.species1;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->frontier.species2;
src/tv.c:            species = (&gSaveBlock1Ptr->tvShows[i])->frontier.facilityAndMode;
src/tv.c:                species = (&gSaveBlock1Ptr->tvShows[i])->frontier.species3;
src/tv.c:                species = (&gSaveBlock1Ptr->tvShows[i])->frontier.species3;
src/tv.c:                species = (&gSaveBlock1Ptr->tvShows[i])->frontier.species4;
src/tv.c:    gSaveBlock1Ptr->tvShows[showIdx].common.active = FALSE;
src/tv.c:        gSaveBlock1Ptr->tvShows[showIdx].common.active = FALSE;
src/tv.c:            if (gSaveBlock1Ptr->tvShows[i].common.kind == TVSHOW_BRAVO_TRAINER_BATTLE_TOWER_PROFILE)
src/tv.c:                gSaveBlock1Ptr->tvShows[i].common.active = FALSE;
src/tv.c:            else if (gSaveBlock1Ptr->tvShows[i].common.kind == TVSHOW_MASS_OUTBREAK)
src/tv.c:                gSaveBlock1Ptr->tvShows[i].common.active = FALSE;
src/tv.c:        if (GetTVGroupByShowId(gSaveBlock1Ptr->tvShows[i].common.kind) == TVGROUP_NORMAL)
src/tv.c:            gSaveBlock1Ptr->tvShows[i].common.active = FALSE;
src/tv.c:        if (gSaveBlock1Ptr->tvShows[i].common.kind == TVSHOW_OFF_AIR)
src/tv.c:        DeleteTVShowInArrayByIdx(gSaveBlock1Ptr->tvShows, i + NUM_NORMAL_TVSHOW_SLOTS);
src/tv.c:            SetMixedPokeNews(gSaveBlock1Ptr->pokeNews, (*rmBuffer)[1], (*rmBuffer)[2], (*rmBuffer)[3]);
src/tv.c:            SetMixedPokeNews((*rmBuffer)[0], gSaveBlock1Ptr->pokeNews, (*rmBuffer)[2], (*rmBuffer)[3]);
src/tv.c:            SetMixedPokeNews((*rmBuffer)[0], (*rmBuffer)[1], gSaveBlock1Ptr->pokeNews, (*rmBuffer)[3]);
src/tv.c:            SetMixedPokeNews((*rmBuffer)[0], (*rmBuffer)[1], (*rmBuffer)[2], gSaveBlock1Ptr->pokeNews);
src/tv.c:        if (gSaveBlock1Ptr->pokeNews[i].kind > POKENEWS_BLENDMASTER)
src/tv.c:            gSaveBlock1Ptr->pokeNews[i].state = POKENEWS_STATE_INACTIVE;
src/tv.c:    if (gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004].common.active)
src/tv.c:        switch (gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004].common.kind)
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:        GetMapName(gStringVar1, gSaveBlock1Ptr->gabbyAndTyData.mapnum, 0);
src/tv.c:        if (gSaveBlock1Ptr->gabbyAndTyData.battleNum > 1)
src/tv.c:        if (!gSaveBlock1Ptr->gabbyAndTyData.battleTookMoreThanOneTurn)
src/tv.c:        else if (gSaveBlock1Ptr->gabbyAndTyData.playerThrewABall)
src/tv.c:        else if (gSaveBlock1Ptr->gabbyAndTyData.playerUsedHealingItem)
src/tv.c:        else if (gSaveBlock1Ptr->gabbyAndTyData.playerLostAMon)
src/tv.c:        StringCopy(gStringVar1, GetSpeciesName(gSaveBlock1Ptr->gabbyAndTyData.mon1));
src/tv.c:        StringCopy(gStringVar2, GetMoveName(gSaveBlock1Ptr->gabbyAndTyData.lastMove));
src/tv.c:        StringCopy(gStringVar3, GetSpeciesName(gSaveBlock1Ptr->gabbyAndTyData.mon2));
src/tv.c:        CopyEasyChatWord(gStringVar1, gSaveBlock1Ptr->gabbyAndTyData.quote[0]);
src/tv.c:        StringCopy(gStringVar2, GetSpeciesName(gSaveBlock1Ptr->gabbyAndTyData.mon1));
src/tv.c:        StringCopy(gStringVar3, GetSpeciesName(gSaveBlock1Ptr->gabbyAndTyData.mon2));
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    show = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004];
src/tv.c:    gSaveBlock1Ptr->tvShows[gSpecialVar_0x8004].common.active = FALSE;
src/trainer_see.c:        ScriptMovement_StartObjectMovementScript(OBJ_EVENT_ID_PLAYER, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, gPostBattleMovementScript);
src/trainer_see.c:        ScriptMovement_StartObjectMovementScript(OBJ_EVENT_ID_PLAYER, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, gPostBattleMovementScript);
src/pokemon.c:        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/pokemon.c:            itemEffect = gSaveBlock1Ptr->enigmaBerry.itemEffect;
src/pokemon.c:            partnerHoldEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/pokemon.c:        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/pokemon.c:                currentMap = ((gSaveBlock1Ptr->location.mapGroup) << 8 | gSaveBlock1Ptr->location.mapNum);
src/pokemon.c:            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/pokemon.c:            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/field_special_scene.c:    SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_TOP,      gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX1_X_OFFSET - cameraXpan, BOX1_Y_OFFSET + yBox1);
src/field_special_scene.c:    SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_L, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX2_X_OFFSET - cameraXpan, BOX2_Y_OFFSET + yBox2);
src/field_special_scene.c:    SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_R, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX3_X_OFFSET - cameraXpan, BOX3_Y_OFFSET + yBox3);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_TOP,      gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX1_X_OFFSET - cameraXpan, BOX1_Y_OFFSET + yBox1);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_L, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX2_X_OFFSET - cameraXpan, BOX2_Y_OFFSET + yBox2);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_R, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX3_X_OFFSET - cameraXpan, BOX3_Y_OFFSET + yBox3);
src/field_special_scene.c:       SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_TOP,      gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX1_X_OFFSET - cameraXpan, BOX1_Y_OFFSET + cameraYpan);
src/field_special_scene.c:       SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_L, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX2_X_OFFSET - cameraXpan, BOX2_Y_OFFSET + cameraYpan);
src/field_special_scene.c:       SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_R, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX3_X_OFFSET - cameraXpan, BOX3_Y_OFFSET + cameraYpan);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_TOP,      gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX1_X_OFFSET, BOX1_Y_OFFSET);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_L, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX2_X_OFFSET, BOX2_Y_OFFSET);
src/field_special_scene.c:        SetObjectEventSpritePosByLocalIdAndMap(LOCALID_TRUCK_BOX_BOTTOM_R, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, BOX3_X_OFFSET, BOX3_Y_OFFSET);
src/field_special_scene.c:    struct WarpData *location = &gSaveBlock1Ptr->location;
src/field_special_scene.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/berry.c:    u8 *dest = (u8 *)&gSaveBlock1Ptr->enigmaBerry;
src/berry.c:    for (i = 0; i < sizeof(gSaveBlock1Ptr->enigmaBerry); i++)
src/berry.c:    for (i = 0; i < sizeof(gSaveBlock1Ptr->enigmaBerry) - sizeof(gSaveBlock1Ptr->enigmaBerry.checksum); i++)
src/berry.c:    if (!gSaveBlock1Ptr->enigmaBerry.berry.growthDuration)
src/berry.c:    if (!gSaveBlock1Ptr->enigmaBerry.berry.maxYield)
src/berry.c:    if (GetEnigmaBerryChecksum(&gSaveBlock1Ptr->enigmaBerry) != gSaveBlock1Ptr->enigmaBerry.checksum)
src/berry.c:        return (struct Berry *)(&gSaveBlock1Ptr->enigmaBerry.berry);
src/berry.c:    return &gSaveBlock1Ptr->berryTrees[id];
src/berry.c:        gSaveBlock1Ptr->berryTrees[i] = gBlankBerryTree;
src/berry.c:        tree = &gSaveBlock1Ptr->berryTrees[i];
src/berry.c:    gSaveBlock1Ptr->berryTrees[id] = gBlankBerryTree;
src/berry.c:    return gSaveBlock1Ptr->berryTrees[id].berry;
src/berry.c:    return gSaveBlock1Ptr->berryTrees[id].stage;
src/berry.c:    return gSaveBlock1Ptr->berryTrees[id].mulch;
src/berry.c:    return gSaveBlock1Ptr->berryTrees[id].berryYield;
src/berry.c:    return (gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].moistureLevel == 0);
src/berry.c:    num = gSaveBlock1Ptr->location.mapNum;
src/berry.c:    group = gSaveBlock1Ptr->location.mapGroup;
src/berry.c:    gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].mulch = mulch;
src/berry.c:    SetBerryTreeJustPicked(gSpecialVar_LastTalked, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/berry.c:    return gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].weeds;
src/berry.c:    if (!OW_BERRY_PESTS || !gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].pests)
src/berry.c:    species = GetBerryPestSpecies(gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].berry);
src/berry.c:    gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(gSelectedObjectEvent)].pests = FALSE;
src/berry.c:                return GetMutationOutcome(berry, gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(j)].berry);
src/battle_script_commands.c:        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/battle_script_commands.c:        AddMoney(&gSaveBlock1Ptr->money, money);
src/battle_script_commands.c:        RemoveMoney(&gSaveBlock1Ptr->money, money);
src/battle_script_commands.c:        AddMoney(&gSaveBlock1Ptr->money, bonusMoney);
src/secret_base.c:        ClearSecretBase(&gSaveBlock1Ptr->secretBases[i]);
src/secret_base.c:        if (sCurSecretBaseId == gSaveBlock1Ptr->secretBases[i].secretBaseId)
src/secret_base.c:    if (gSaveBlock1Ptr->secretBases[0].secretBaseId)
src/secret_base.c:    gSaveBlock1Ptr->secretBases[0].secretBaseId = sCurSecretBaseId;
src/secret_base.c:        gSaveBlock1Ptr->secretBases[0].trainerId[i] = gSaveBlock2Ptr->playerTrainerId[i];
src/secret_base.c:    StringCopyN(gSaveBlock1Ptr->secretBases[0].trainerName, gSaveBlock2Ptr->playerName, GetNameLength(gSaveBlock2Ptr->playerName));
src/secret_base.c:    gSaveBlock1Ptr->secretBases[0].gender = gSaveBlock2Ptr->playerGender;
src/secret_base.c:    gSaveBlock1Ptr->secretBases[0].language = GAME_LANGUAGE;
src/secret_base.c:                if (gSaveBlock1Ptr->secretBases[j].secretBaseId == events->bgEvents[bgId].bgUnion.secretBaseId)
src/secret_base.c:        if (gSaveBlock1Ptr->secretBases[secretBaseIdx].numTimesEntered < 255)
src/secret_base.c:            gSaveBlock1Ptr->secretBases[secretBaseIdx].numTimesEntered++;
src/secret_base.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/secret_base.c:            gSaveBlock1Ptr->location.mapGroup,
src/secret_base.c:            gSaveBlock1Ptr->location.mapNum,
src/secret_base.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(SECRET_BASE_RED_CAVE1)
src/secret_base.c:     && (u8)gSaveBlock1Ptr->location.mapNum <= MAP_NUM(SECRET_BASE_SHRUB4))
src/secret_base.c:        decorations = gSaveBlock1Ptr->secretBases[secretBaseIdx].decorations;
src/secret_base.c:        decorPos = gSaveBlock1Ptr->secretBases[secretBaseIdx].decorationPositions;
src/secret_base.c:        decorations = gSaveBlock1Ptr->playerRoomDecorations;
src/secret_base.c:        decorationPositions = gSaveBlock1Ptr->playerRoomDecorationPositions;
src/secret_base.c:        decorations = gSaveBlock1Ptr->secretBases[secretBaseIdx].decorations;
src/secret_base.c:        decorationPositions = gSaveBlock1Ptr->secretBases[secretBaseIdx].decorationPositions;
src/secret_base.c:                TrySpawnObjectEvent(gSpecialVar_Result, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/secret_base.c:                TryMoveObjectEventToMapCoords(gSpecialVar_Result, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, gSpecialVar_0x8006, gSpecialVar_0x8007);
src/secret_base.c:                TryOverrideObjectEventTemplateCoords(gSpecialVar_Result, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/secret_base.c:                            gSaveBlock1Ptr->location.mapNum,
src/secret_base.c:                            gSaveBlock1Ptr->location.mapGroup,
src/secret_base.c:                            gSaveBlock1Ptr->location.mapNum,
src/secret_base.c:                            gSaveBlock1Ptr->location.mapGroup,
src/secret_base.c:                gSaveBlock1Ptr->location.mapNum,
src/secret_base.c:                gSaveBlock1Ptr->location.mapGroup);
src/secret_base.c:    if (gSaveBlock1Ptr->secretBases[0].secretBaseId != sCurSecretBaseId)
src/secret_base.c:    *StringCopyN(dest, gSaveBlock1Ptr->secretBases[secretBaseIdx].trainerName, GetNameLength(gSaveBlock1Ptr->secretBases[secretBaseIdx].trainerName)) = EOS;
src/secret_base.c:    ConvertInternationalString(dest, gSaveBlock1Ptr->secretBases[secretBaseIdx].language);
src/secret_base.c:    name = gSaveBlock1Ptr->secretBases[secretBaseIdx].trainerName;
src/secret_base.c:    ConvertInternationalString(gStringVar1, gSaveBlock1Ptr->secretBases[secretBaseIdx].language);
src/secret_base.c:    if (gSaveBlock1Ptr->secretBases[secretBaseIdx].registryStatus)
src/secret_base.c:    party = &gSaveBlock1Ptr->secretBases[0].party;
src/secret_base.c:    if (gSaveBlock1Ptr->secretBases[0].secretBaseId)
src/secret_base.c:    u16 temp = gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived;
src/secret_base.c:    ClearSecretBase(&gSaveBlock1Ptr->secretBases[0]);
src/secret_base.c:    gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived = temp;
src/secret_base.c:         && gSaveBlock1Ptr->secretBases[0].secretBaseId == events->bgEvents[i].bgUnion.secretBaseId)
src/secret_base.c:    temp = gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived;
src/secret_base.c:    ClearSecretBase(&gSaveBlock1Ptr->secretBases[0]);
src/secret_base.c:    gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived = temp;
src/secret_base.c:    gSaveBlock1Ptr->secretBases[VarGet(VAR_CURRENT_SECRET_BASE)].registryStatus ^= 1;
src/secret_base.c:    gSaveBlock1Ptr->secretBases[tSelectedBaseId].registryStatus = UNREGISTERED;
src/secret_base.c:    return (gSaveBlock1Ptr->secretBases[secretBaseIdx].trainerId[0] % 5)
src/secret_base.c:         + (gSaveBlock1Ptr->secretBases[secretBaseIdx].gender * 5);
src/secret_base.c:    gSaveBlock1Ptr->secretBases[VarGet(VAR_CURRENT_SECRET_BASE)].battledOwnerToday = gSpecialVar_Result;
src/secret_base.c:            gSaveBlock1Ptr->secretBases[i].battledOwnerToday = FALSE;
src/secret_base.c:    gSpecialVar_Result = gSaveBlock1Ptr->secretBases[secretBaseIdx].battledOwnerToday;
src/secret_base.c:    gSaveBlock1Ptr->secretBases[secretBaseIdx] = *secretBase;
src/secret_base.c:    gSaveBlock1Ptr->secretBases[secretBaseIdx].registryStatus = NEW;
src/secret_base.c:        gSaveBlock1Ptr->secretBases[secretBaseIdx].language = GAME_LANGUAGE;
src/secret_base.c:        name = gSaveBlock1Ptr->secretBases[secretBaseIdx].trainerName;
src/secret_base.c:            gSaveBlock1Ptr->secretBases[secretBaseIdx].language = GAME_LANGUAGE;
src/secret_base.c:        if (gSaveBlock1Ptr->secretBases[i].secretBaseId == secretBaseId)
src/secret_base.c:        if (gSaveBlock1Ptr->secretBases[i].secretBaseId == 0)
src/secret_base.c:        if (gSaveBlock1Ptr->secretBases[i].registryStatus == UNREGISTERED && gSaveBlock1Ptr->secretBases[i].toRegister == FALSE)
src/secret_base.c:            if (gSaveBlock1Ptr->secretBases[index].toRegister == TRUE)
src/secret_base.c:            if (gSaveBlock1Ptr->secretBases[index].registryStatus != NEW || secretBase->toRegister == TRUE)
src/secret_base.c:    secretBases = gSaveBlock1Ptr->secretBases;
src/secret_base.c:    ClearDuplicateOwnedSecretBases(gSaveBlock1Ptr->secretBases, mixers[0].secretBases, mixers[1].secretBases, mixers[2].secretBases);
src/secret_base.c:            if (gSaveBlock1Ptr->secretBases[i].toRegister == TRUE)
src/secret_base.c:                gSaveBlock1Ptr->secretBases[i].registryStatus = REGISTERED;
src/secret_base.c:                gSaveBlock1Ptr->secretBases[i].toRegister = FALSE;
src/secret_base.c:            if (gSaveBlock1Ptr->secretBases[i].registryStatus == NEW)
src/secret_base.c:                gSaveBlock1Ptr->secretBases[i].registryStatus = UNREGISTERED;
src/secret_base.c:        if (gSaveBlock1Ptr->secretBases[0].secretBaseId != 0
src/secret_base.c:         && gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived != 0xFFFF)
src/secret_base.c:            gSaveBlock1Ptr->secretBases[0].numSecretBasesReceived++;
src/contest_painting.c:    gCurContestWinner = gSaveBlock1Ptr->contestWinners[contestWinnerId - 1];
src/daycare.c:        u16 moveLearnerSpecies = GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[i].mon, MON_DATA_SPECIES);
src/daycare.c:        if (!GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[i].mon, MON_DATA_SANITY_HAS_SPECIES))
src/daycare.c:                u16 moveTeacherSpecies = GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[k].mon, MON_DATA_SPECIES);
src/daycare.c:                if (k == i || !GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[k].mon, MON_DATA_SANITY_HAS_SPECIES))
src/daycare.c:                    && (P_EGG_MOVE_TRANSFER < GEN_9 || GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[i].mon, MON_DATA_HELD_ITEM) != ITEM_MIRROR_HERB)
src/daycare.c:                    if (GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[k].mon, MON_DATA_MOVE1 + l) != sHatchedEggEggMoves[j])
src/daycare.c:                    if (GiveMoveToBoxMon(&gSaveBlock1Ptr->daycare.mons[i].mon, sHatchedEggEggMoves[j]) == MON_HAS_MAX_MOVES)
src/daycare.c:        daycareMon->mail.message = gSaveBlock1Ptr->mail[mailId];
src/daycare.c:    StorePokemonInEmptyDaycareSlot(&gPlayerParty[monId], &gSaveBlock1Ptr->daycare);
src/daycare.c:    return TakeSelectedPokemonMonFromDaycareShiftSlots(&gSaveBlock1Ptr->daycare, gSpecialVar_0x8004);
src/daycare.c:    gSpecialVar_0x8005 = GetDaycareCostForMon(&gSaveBlock1Ptr->daycare, gSpecialVar_0x8004);
src/daycare.c:    gSaveBlock1Ptr->daycare.mons[0].steps += numSteps;
src/daycare.c:    gSaveBlock1Ptr->daycare.mons[1].steps += numSteps;
src/daycare.c:    if (GetBoxMonData(&gSaveBlock1Ptr->daycare.mons[gSpecialVar_0x8004].mon, MON_DATA_SPECIES) != 0)
src/daycare.c:        return GetNumLevelsGainedForDaycareMon(&gSaveBlock1Ptr->daycare.mons[gSpecialVar_0x8004]);
src/daycare.c:    _TriggerPendingDaycareEgg(&gSaveBlock1Ptr->daycare);
src/daycare.c:    _TriggerPendingDaycareMaleEgg(&gSaveBlock1Ptr->daycare);
src/daycare.c:    RemoveEggFromDayCare(&gSaveBlock1Ptr->daycare);
src/daycare.c:    _GiveEggFromDaycare(&gSaveBlock1Ptr->daycare);
src/daycare.c:    return TryProduceOrHatchEgg(&gSaveBlock1Ptr->daycare);
src/daycare.c:    _GetDaycareMonNicknames(&gSaveBlock1Ptr->daycare);
src/daycare.c:    if (IsEggPending(&gSaveBlock1Ptr->daycare))
src/daycare.c:    numMons = CountPokemonInDaycare(&gSaveBlock1Ptr->daycare);
src/daycare.c:    u8 ret = CountPokemonInDaycare(&gSaveBlock1Ptr->daycare);
src/daycare.c:    gSpecialVar_Result = GetDaycareCompatibilityScore(&gSaveBlock1Ptr->daycare);
src/daycare.c:        DaycarePrintMonNickname(&gSaveBlock1Ptr->daycare, windowId, daycareSlotId, y);
src/daycare.c:        DaycarePrintMonLvl(&gSaveBlock1Ptr->daycare, windowId, daycareSlotId, y);
src/load_save.c:    gSaveBlock1Ptr->playerPartyCount = gPlayerPartyCount;
src/load_save.c:        gSaveBlock1Ptr->playerParty[i] = gPlayerParty[i];
src/load_save.c:    gPlayerPartyCount = gSaveBlock1Ptr->playerPartyCount;
src/load_save.c:        gPlayerParty[i] = gSaveBlock1Ptr->playerParty[i];
src/load_save.c:        gSaveBlock1Ptr->objectEvents[i] = gObjectEvents[i];
src/load_save.c:        gSaveBlock1Ptr->objectEvents[i].graphicsId = (graphicsId >> 8) | (graphicsId << 8);
src/load_save.c:        gSaveBlock1Ptr->objectEvents[i].spriteId = 127; // magic number
src/load_save.c:            gSaveBlock1Ptr->objectEvents[i].active = FALSE;
src/load_save.c:        gObjectEvents[i] = gSaveBlock1Ptr->objectEvents[i];
src/load_save.c:        gLoadedSaveData.items[i] = gSaveBlock1Ptr->bagPocket_Items[i];
src/load_save.c:        gLoadedSaveData.keyItems[i] = gSaveBlock1Ptr->bagPocket_KeyItems[i];
src/load_save.c:        gLoadedSaveData.pokeBalls[i] = gSaveBlock1Ptr->bagPocket_PokeBalls[i];
src/load_save.c:        gLoadedSaveData.TMsHMs[i] = gSaveBlock1Ptr->bagPocket_TMHM[i];
src/load_save.c:        gLoadedSaveData.berries[i] = gSaveBlock1Ptr->bagPocket_Berries[i];
src/load_save.c:        gLoadedSaveData.mail[i] = gSaveBlock1Ptr->mail[i];
src/load_save.c:        gSaveBlock1Ptr->bagPocket_Items[i] = gLoadedSaveData.items[i];
src/load_save.c:        gSaveBlock1Ptr->bagPocket_KeyItems[i] = gLoadedSaveData.keyItems[i];
src/load_save.c:        gSaveBlock1Ptr->bagPocket_PokeBalls[i] = gLoadedSaveData.pokeBalls[i];
src/load_save.c:        gSaveBlock1Ptr->bagPocket_TMHM[i] = gLoadedSaveData.TMsHMs[i];
src/load_save.c:        gSaveBlock1Ptr->bagPocket_Berries[i] = gLoadedSaveData.berries[i];
src/load_save.c:        gSaveBlock1Ptr->mail[i] = gLoadedSaveData.mail[i];
src/load_save.c:    ApplyNewEncryptionKeyToWord(&gSaveBlock1Ptr->money, encryptionKey);
src/load_save.c:    ApplyNewEncryptionKeyToHword(&gSaveBlock1Ptr->coins, encryptionKey);
src/dewford_trend.c:    Each time a potential trendy phrase is submitted, it is saved in gSaveBlock1Ptr->dewfordTrends[].
src/dewford_trend.c:    gSaveBlock1Ptr->dewfordTrends[0]. If the player mixes records with another player, their own
src/dewford_trend.c:        gSaveBlock1Ptr->dewfordTrends[i].words[0] = GetRandomEasyChatWordFromGroup(EC_GROUP_CONDITIONS);
src/dewford_trend.c:            gSaveBlock1Ptr->dewfordTrends[i].words[1] = GetRandomEasyChatWordFromGroup(EC_GROUP_LIFESTYLE);
src/dewford_trend.c:            gSaveBlock1Ptr->dewfordTrends[i].words[1] = GetRandomEasyChatWordFromGroup(EC_GROUP_HOBBIES);
src/dewford_trend.c:        gSaveBlock1Ptr->dewfordTrends[i].gainingTrendiness = Random() & 1;
src/dewford_trend.c:        SeedTrendRng(&(gSaveBlock1Ptr->dewfordTrends[i]));
src/dewford_trend.c:    SortTrends(gSaveBlock1Ptr->dewfordTrends, SAVED_TRENDS_COUNT, SORT_MODE_NORMAL);
src/dewford_trend.c:            struct DewfordTrend *trend = &gSaveBlock1Ptr->dewfordTrends[i];
src/dewford_trend.c:        SortTrends(gSaveBlock1Ptr->dewfordTrends, SAVED_TRENDS_COUNT, SORT_MODE_NORMAL);
src/dewford_trend.c:// phrase is always saved in gSaveBlock1Ptr->dewfordTrends
src/dewford_trend.c:                gSaveBlock1Ptr->dewfordTrends[0].words[0] = phrase[0];
src/dewford_trend.c:                gSaveBlock1Ptr->dewfordTrends[0].words[1] = phrase[1];
src/dewford_trend.c:            if (CompareTrends(&trend, &(gSaveBlock1Ptr->dewfordTrends[i]), SORT_MODE_NORMAL))
src/dewford_trend.c:                    gSaveBlock1Ptr->dewfordTrends[j] = gSaveBlock1Ptr->dewfordTrends[j - 1];
src/dewford_trend.c:                gSaveBlock1Ptr->dewfordTrends[i] = trend;
src/dewford_trend.c:        gSaveBlock1Ptr->dewfordTrends[SAVED_TRENDS_COUNT - 1] = trend;
src/dewford_trend.c:    dst = gSaveBlock1Ptr->dewfordTrends;
src/dewford_trend.c:    struct DewfordTrend *trend = &gSaveBlock1Ptr->dewfordTrends[gSpecialVar_0x8004];
src/dewford_trend.c:        if (gSaveBlock1Ptr->dewfordTrends[0].trendiness - gSaveBlock1Ptr->dewfordTrends[1].trendiness > 1)
src/dewford_trend.c:        if (gSaveBlock1Ptr->dewfordTrends[0].gainingTrendiness)
src/dewford_trend.c:        if (!gSaveBlock1Ptr->dewfordTrends[1].gainingTrendiness)
src/dewford_trend.c:    gSpecialVar_Result = (gSaveBlock1Ptr->dewfordTrends[0].words[0] + gSaveBlock1Ptr->dewfordTrends[0].words[1]) & 7;
src/dewford_trend.c:        if (IsEasyChatPairEqual(phrase, gSaveBlock1Ptr->dewfordTrends[i].words))
src/battle_pike.c:        int heldItem = GetMonData(&gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[i] - 1],
src/decoration.c:        sDecorationContext.items = gSaveBlock1Ptr->secretBases[0].decorations;
src/decoration.c:        sDecorationContext.pos = gSaveBlock1Ptr->secretBases[0].decorationPositions;
src/decoration.c:        sDecorationContext.items = gSaveBlock1Ptr->playerRoomDecorations;
src/decoration.c:        sDecorationContext.pos = gSaveBlock1Ptr->playerRoomDecorationPositions;
src/decoration.c:    sDecorationContext.items = gSaveBlock1Ptr->secretBases[0].decorations;
src/decoration.c:    sDecorationContext.pos = gSaveBlock1Ptr->secretBases[0].decorationPositions;
src/decoration.c:    sDecorationContext.items = gSaveBlock1Ptr->playerRoomDecorations;
src/decoration.c:    sDecorationContext.pos = gSaveBlock1Ptr->playerRoomDecorationPositions;
src/decoration.c:        if (gSaveBlock1Ptr->secretBases[0].decorations[i] != DECOR_NONE)
src/decoration.c:                if (gCurDecorationItems[j] == gSaveBlock1Ptr->secretBases[0].decorations[i])
src/decoration.c:        if (gSaveBlock1Ptr->playerRoomDecorations[i] != DECOR_NONE)
src/decoration.c:                if (gCurDecorationItems[j] == gSaveBlock1Ptr->playerRoomDecorations[i] && IsDecorationIndexInSecretBase(j + 1) != TRUE)
src/decoration.c:    gTasks[taskId].tInitialX = gSaveBlock1Ptr->pos.x;
src/decoration.c:    gTasks[taskId].tInitialY = gSaveBlock1Ptr->pos.y;
src/decoration.c:    SetWarpDestination(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE, gTasks[taskId].tInitialX, gTasks[taskId].tInitialY);
src/decoration.c:            TrySpawnObjectEvent(gSpecialVar_0x8005, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/decoration.c:            TryMoveObjectEventToMapCoords(gSpecialVar_0x8005, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, gSpecialVar_0x8006, gSpecialVar_0x8007);
src/decoration.c:            TryOverrideObjectEventTemplateCoords(gSpecialVar_0x8005, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/decoration.c:        if (gSaveBlock1Ptr->objectEventTemplates[i].x == xOff && gSaveBlock1Ptr->objectEventTemplates[i].y == yOff && !FlagGet(gSaveBlock1Ptr->objectEventTemplates[i].flagId))
src/decoration.c:            sDecorRearrangementDataBuffer[sCurDecorSelectedInRearrangement].flagId = gSaveBlock1Ptr->objectEventTemplates[i].flagId;
src/mirage_tower.c:    if (!(gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE111) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE111)))
src/mirage_tower.c:    if (gSaveBlock1Ptr->location.mapGroup != MAP_GROUP(ROUTE111)
src/mirage_tower.c:     || gSaveBlock1Ptr->location.mapNum != MAP_NUM(ROUTE111)
src/mirage_tower.c:    if (gSaveBlock1Ptr->location.mapGroup != MAP_GROUP(ROUTE111)
src/mirage_tower.c:     || gSaveBlock1Ptr->location.mapNum   != MAP_NUM(ROUTE111)
src/mirage_tower.c:    TryGetObjectEventIdByLocalIdAndMap(LOCALID_ROUTE111_PLAYER_FALLING, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objectEventId);
src/battle_arena.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/script.c:    return CalcCRC16WithTable((u8 *)(&gSaveBlock1Ptr->ramScript.data), sizeof(gSaveBlock1Ptr->ramScript.data));
src/script.c:    CpuFill32(0, &gSaveBlock1Ptr->ramScript, sizeof(struct RamScript));
src/script.c:    struct RamScriptData *scriptData = &gSaveBlock1Ptr->ramScript.data;
src/script.c:    gSaveBlock1Ptr->ramScript.checksum = CalculateRamScriptChecksum();
src/script.c:    struct RamScriptData *scriptData = &gSaveBlock1Ptr->ramScript.data;
src/script.c:    if (scriptData->mapGroup != gSaveBlock1Ptr->location.mapGroup)
src/script.c:    if (scriptData->mapNum != gSaveBlock1Ptr->location.mapNum)
src/script.c:    if (CalculateRamScriptChecksum() != gSaveBlock1Ptr->ramScript.checksum)
src/script.c:    struct RamScriptData *scriptData = &gSaveBlock1Ptr->ramScript.data;
src/script.c:    if (CalculateRamScriptChecksum() != gSaveBlock1Ptr->ramScript.checksum)
src/script.c:    struct RamScriptData *scriptData = &gSaveBlock1Ptr->ramScript.data;
src/script.c:    if (CalculateRamScriptChecksum() != gSaveBlock1Ptr->ramScript.checksum)
src/script.c:    if (scriptSize > sizeof(gSaveBlock1Ptr->ramScript.data.script))
src/script.c:        scriptSize = sizeof(gSaveBlock1Ptr->ramScript.data.script);
src/mystery_gift.c:    CpuFill32(0, &gSaveBlock1Ptr->mysteryGift, sizeof(gSaveBlock1Ptr->mysteryGift));
src/mystery_gift.c:    return &gSaveBlock1Ptr->mysteryGift.news;
src/mystery_gift.c:    return &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:    return &gSaveBlock1Ptr->mysteryGift.cardMetadata;
src/mystery_gift.c:    return &gSaveBlock1Ptr->mysteryGift.newsMetadata;
src/mystery_gift.c:    return gSaveBlock1Ptr->mysteryGift.questionnaireWords;
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.news = *news;
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.newsCrc = CALC_CRC(gSaveBlock1Ptr->mysteryGift.news);
src/mystery_gift.c:    if (CALC_CRC(gSaveBlock1Ptr->mysteryGift.news) != gSaveBlock1Ptr->mysteryGift.newsCrc)
src/mystery_gift.c:    if (!ValidateWonderNews(&gSaveBlock1Ptr->mysteryGift.news))
src/mystery_gift.c:    const struct WonderNews *news = &gSaveBlock1Ptr->mysteryGift.news;
src/mystery_gift.c:    CpuFill32(0, GetSavedWonderNews(), sizeof(gSaveBlock1Ptr->mysteryGift.news));
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.newsCrc = 0;
src/mystery_gift.c:    CpuFill32(0, GetSavedWonderNewsMetadata(), sizeof(gSaveBlock1Ptr->mysteryGift.newsMetadata));
src/mystery_gift.c:    const u8 *savedNews = (const u8 *)&gSaveBlock1Ptr->mysteryGift.news;
src/mystery_gift.c:    for (i = 0; i < sizeof(gSaveBlock1Ptr->mysteryGift.news); i++)
src/mystery_gift.c:    memcpy(&gSaveBlock1Ptr->mysteryGift.card, card, sizeof(struct WonderCard));
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.cardCrc = CALC_CRC(gSaveBlock1Ptr->mysteryGift.card);
src/mystery_gift.c:    metadata = &gSaveBlock1Ptr->mysteryGift.cardMetadata;
src/mystery_gift.c:    metadata->iconSpecies = (&gSaveBlock1Ptr->mysteryGift.card)->iconSpecies;
src/mystery_gift.c:    if (gSaveBlock1Ptr->mysteryGift.cardCrc != CALC_CRC(gSaveBlock1Ptr->mysteryGift.card))
src/mystery_gift.c:    if (!ValidateWonderCard(&gSaveBlock1Ptr->mysteryGift.card))
src/mystery_gift.c:    const struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:    CpuFill32(0, &gSaveBlock1Ptr->mysteryGift.card, sizeof(gSaveBlock1Ptr->mysteryGift.card));
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.cardCrc = 0;
src/mystery_gift.c:    CpuFill32(0, GetSavedWonderCardMetadata(), sizeof(gSaveBlock1Ptr->mysteryGift.cardMetadata));
src/mystery_gift.c:    gSaveBlock1Ptr->mysteryGift.cardMetadataCrc = 0;
src/mystery_gift.c:        return gSaveBlock1Ptr->mysteryGift.card.flagId;
src/mystery_gift.c:    card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:    return GetNumStampsInMetadata(&gSaveBlock1Ptr->mysteryGift.cardMetadata, card->maxStamps);
src/mystery_gift.c:    struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:    if (IsStampInMetadata(&gSaveBlock1Ptr->mysteryGift.cardMetadata, stamp, maxStamps))
src/mystery_gift.c:        if (gSaveBlock1Ptr->mysteryGift.cardMetadata.stampData[STAMP_ID][i] == 0
src/mystery_gift.c:         && gSaveBlock1Ptr->mysteryGift.cardMetadata.stampData[STAMP_SPECIES][i] == SPECIES_NONE)
src/mystery_gift.c:            gSaveBlock1Ptr->mysteryGift.cardMetadata.stampData[STAMP_ID][i] = stamp[STAMP_ID];
src/mystery_gift.c:            gSaveBlock1Ptr->mysteryGift.cardMetadata.stampData[STAMP_SPECIES][i] = stamp[STAMP_SPECIES];
src/mystery_gift.c:        data->questionnaireWords[i] = gSaveBlock1Ptr->mysteryGift.questionnaireWords[i];
src/mystery_gift.c:        data->easyChatProfile[i] = gSaveBlock1Ptr->easyChatProfile[i];
src/mystery_gift.c:    struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:            stat = &gSaveBlock1Ptr->mysteryGift.cardMetadata.battlesWon;
src/mystery_gift.c:            stat = &gSaveBlock1Ptr->mysteryGift.cardMetadata.battlesLost;
src/mystery_gift.c:            stat = &gSaveBlock1Ptr->mysteryGift.cardMetadata.numTrades;
src/mystery_gift.c:        struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:            struct WonderCardMetadata *metadata = &gSaveBlock1Ptr->mysteryGift.cardMetadata;
src/mystery_gift.c:        struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:            struct WonderCardMetadata *metadata = &gSaveBlock1Ptr->mysteryGift.cardMetadata;
src/mystery_gift.c:        struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:            struct WonderCardMetadata *metadata = &gSaveBlock1Ptr->mysteryGift.cardMetadata;
src/mystery_gift.c:        struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:        struct WonderCard *card = &gSaveBlock1Ptr->mysteryGift.card;
src/mystery_gift.c:    if (gSaveBlock1Ptr->mysteryGift.card.flagId != flagId)
src/mystery_gift.c:                                            gSaveBlock1Ptr->mysteryGift.trainerIds[1],
src/mystery_gift.c:                                            ARRAY_COUNT(gSaveBlock1Ptr->mysteryGift.trainerIds[1]));
src/mystery_gift.c:                                            gSaveBlock1Ptr->mysteryGift.trainerIds[0],
src/mystery_gift.c:                                            ARRAY_COUNT(gSaveBlock1Ptr->mysteryGift.trainerIds[0]));
src/mystery_gift.c:                                            gSaveBlock1Ptr->mysteryGift.trainerIds[0],
src/mystery_gift.c:                                            ARRAY_COUNT(gSaveBlock1Ptr->mysteryGift.trainerIds[0]));
src/mystery_gift.c:    CpuFill32(0, gSaveBlock1Ptr->mysteryGift.trainerIds, sizeof(gSaveBlock1Ptr->mysteryGift.trainerIds));
src/shop.c:    PrintMoneyAmountInMoneyBoxWithBorder(WIN_MONEY, 1, 13, GetMoney(&gSaveBlock1Ptr->money));
src/shop.c:            else if (!IsEnoughMoney(&gSaveBlock1Ptr->money, sShopData->totalCost))
src/shop.c:        maxQuantity = GetMoney(&gSaveBlock1Ptr->money) / sShopData->totalCost;
src/shop.c:    RemoveMoney(&gSaveBlock1Ptr->money, sShopData->totalCost);
src/shop.c:    PrintMoneyAmountInMoneyBox(WIN_MONEY, GetMoney(&gSaveBlock1Ptr->money), 0);
src/field_effect_helpers.c:    gFieldEffectArguments[1] = gSaveBlock1Ptr->location.mapNum;
src/field_effect_helpers.c:    gFieldEffectArguments[2] = gSaveBlock1Ptr->location.mapGroup;
src/field_effect_helpers.c:    if (gCamera.active && (gSaveBlock1Ptr->location.mapNum != mapNum || gSaveBlock1Ptr->location.mapGroup != mapGroup))
src/field_effect_helpers.c:        sprite->sCurrentMap = ((u8)gSaveBlock1Ptr->location.mapNum << 8) | (u8)gSaveBlock1Ptr->location.mapGroup;
src/field_effect_helpers.c:    if (gCamera.active && (gSaveBlock1Ptr->location.mapNum != mapNum || gSaveBlock1Ptr->location.mapGroup != mapGroup))
src/field_effect_helpers.c:        sprite->sCurrentMap = ((u8)gSaveBlock1Ptr->location.mapNum << 8) | (u8)gSaveBlock1Ptr->location.mapGroup;
src/trade.c:        Trade_Memcpy(gBlockSendBuffer, gSaveBlock1Ptr->mail, PARTY_SIZE * sizeof(struct Mail) + 4);
src/trade.c:        Trade_Memcpy(gBlockSendBuffer, gSaveBlock1Ptr->giftRibbons, sizeof(sTradeMenu->giftRibbons));
src/trade.c:        if (gSaveBlock1Ptr->giftRibbons[i] == 0 && sTradeMenu->giftRibbons[i] != 0)
src/trade.c:                gSaveBlock1Ptr->giftRibbons[i] = sTradeMenu->giftRibbons[i];
src/trade.c:        ClearMail(&gSaveBlock1Ptr->mail[playerMail]);
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/trader.c:    struct MauvilleOldManTrader *trader = &gSaveBlock1Ptr->oldMan.trader;
src/lilycove_lady.c:    return gSaveBlock1Ptr->lilycoveLady.id;
src/lilycove_lady.c:        lilycoveLady = &gSaveBlock1Ptr->lilycoveLady;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sFavorLadyPtr = &gSaveBlock1Ptr->lilycoveLady.favor;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    struct LilycoveLadyQuiz *quiz = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sQuizLadyPtr = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/lilycove_lady.c:    sContestLadyPtr = &gSaveBlock1Ptr->lilycoveLady.contest;
src/save_location.c:    u16 map = (gSaveBlock1Ptr->location.mapGroup << 8) + gSaveBlock1Ptr->location.mapNum;
src/rotating_gate.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(FORTREE_CITY_GYM) &&
src/rotating_gate.c:        gSaveBlock1Ptr->location.mapNum == MAP_NUM(FORTREE_CITY_GYM))
src/rotating_gate.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE110_TRICK_HOUSE_PUZZLE6) &&
src/rotating_gate.c:        gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE110_TRICK_HOUSE_PUZZLE6))
src/rotating_gate.c:    s16 x = gSaveBlock1Ptr->pos.x - 2;
src/rotating_gate.c:    s16 x2 = gSaveBlock1Ptr->pos.x + MAP_OFFSET_W + 2;
src/rotating_gate.c:    s16 y = gSaveBlock1Ptr->pos.y - 2;
src/rotating_gate.c:    s16 y2 = gSaveBlock1Ptr->pos.y + MAP_OFFSET_H;
src/rotating_gate.c:    s16 x = gSaveBlock1Ptr->pos.x - 2;
src/rotating_gate.c:    s16 x2 = gSaveBlock1Ptr->pos.x + MAP_OFFSET_W + 2;
src/rotating_gate.c:    s16 y = gSaveBlock1Ptr->pos.y - 2;
src/rotating_gate.c:    s16 y2 = gSaveBlock1Ptr->pos.y + MAP_OFFSET_H;
src/battle_dome.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/battle_dome.c:                if (GetMonData(&gSaveBlock1Ptr->playerParty[playerMonId], MON_DATA_MOVE1 + count, NULL) == GetMonData(&gPlayerParty[i], MON_DATA_MOVE1 + moveSlot, NULL))
src/battle_dome.c:        gSaveBlock1Ptr->playerParty[playerMonId] = gPlayerParty[i];
src/battle_dome.c:        u16 item = GetMonData(&gSaveBlock1Ptr->playerParty[playerMonId], MON_DATA_HELD_ITEM, NULL);
src/match_call.c:    return gSaveBlock1Ptr->trainerRematches[matchCallId] > 0;
src/match_call.c:    dewfordRand = gSaveBlock1Ptr->dewfordTrends[0].rand;
src/mail_data.c:        ClearMail(&gSaveBlock1Ptr->mail[i]);
src/mail_data.c:        if (gSaveBlock1Ptr->mail[id].itemId == ITEM_NONE)
src/mail_data.c:                gSaveBlock1Ptr->mail[id].words[i] = EC_EMPTY_WORD;
src/mail_data.c:                gSaveBlock1Ptr->mail[id].playerName[i] = gSaveBlock2Ptr->playerName[i];
src/mail_data.c:            gSaveBlock1Ptr->mail[id].playerName[i] = EOS;
src/mail_data.c:            PadNameString(gSaveBlock1Ptr->mail[id].playerName, CHAR_SPACE);
src/mail_data.c:                gSaveBlock1Ptr->mail[id].trainerId[i] = gSaveBlock2Ptr->playerTrainerId[i];
src/mail_data.c:            gSaveBlock1Ptr->mail[id].species = SpeciesToMailSpecies(species, personality);
src/mail_data.c:            gSaveBlock1Ptr->mail[id].itemId = itemId;
src/mail_data.c:    gSaveBlock1Ptr->mail[mailId] = *mail;
src/mail_data.c:        gSaveBlock1Ptr->mail[mailId].itemId = ITEM_NONE;
src/mail_data.c:    gSaveBlock1Ptr->mail[mailId].itemId = ITEM_NONE;
src/mail_data.c:        if (gSaveBlock1Ptr->mail[i].itemId == ITEM_NONE)
src/mail_data.c:            memcpy(&gSaveBlock1Ptr->mail[i], &gSaveBlock1Ptr->mail[GetMonData(mon, MON_DATA_MAIL)], sizeof(struct Mail));
src/mail_data.c:            gSaveBlock1Ptr->mail[GetMonData(mon, MON_DATA_MAIL)].itemId = ITEM_NONE;
src/battle_factory.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/pokeblock.c:    struct Pokeblock *pkblock = &gSaveBlock1Ptr->pokeblocks[pkblId];
src/pokeblock.c:        pokeblock = &gSaveBlock1Ptr->pokeblocks[pkblId];
src/pokeblock.c:            if (gSaveBlock1Ptr->pokeblocks[i].color == PBLOCK_CLR_NONE)
src/pokeblock.c:                struct Pokeblock temp = gSaveBlock1Ptr->pokeblocks[i];
src/pokeblock.c:                gSaveBlock1Ptr->pokeblocks[i] = gSaveBlock1Ptr->pokeblocks[j];
src/pokeblock.c:                gSaveBlock1Ptr->pokeblocks[j] = temp;
src/pokeblock.c:    struct Pokeblock *pokeblocks = gSaveBlock1Ptr->pokeblocks;
src/pokeblock.c:        if (gSaveBlock1Ptr->pokeblocks[i].color != PBLOCK_CLR_NONE)
src/pokeblock.c:    ChooseMonToGivePokeblock(&gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId], ReturnToPokeblockCaseOnField);
src/pokeblock.c:    StringCopy(gStringVar1, gPokeblockNames[gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId].color]);
src/pokeblock.c:    s16 gain = PokeblockGetGain(nature, &gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId]);
src/pokeblock.c:    StringCopy(gBattleTextBuff1, gPokeblockNames[gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId].color]);
src/pokeblock.c:    gSpecialVar_ItemId = gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId].color << 8;
src/pokeblock.c:    StringCopy(gStringVar1, gPokeblockNames[gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId].color]);
src/pokeblock.c:    gSpecialVar_0x8004 = GivePokeblockToContestLady(&gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId]);
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].color = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].spicy = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].dry = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].sweet = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].bitter = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].sour = 0;
src/pokeblock.c:    gSaveBlock1Ptr->pokeblocks[pkblId].feel = 0;
src/pokeblock.c:        if (gSaveBlock1Ptr->pokeblocks[i].color == PBLOCK_CLR_NONE)
src/pokeblock.c:        gSaveBlock1Ptr->pokeblocks[slot] = *pokeblock;
src/pokeblock.c:    if (gSaveBlock1Ptr->pokeblocks[pkblId].color == PBLOCK_CLR_NONE)
src/mauville_old_man.c:    struct MauvilleManBard *bard = &gSaveBlock1Ptr->oldMan.bard;
src/mauville_old_man.c:    struct MauvilleManHipster *hipster = &gSaveBlock1Ptr->oldMan.hipster;
src/mauville_old_man.c:    struct MauvilleManGiddy *giddy = &gSaveBlock1Ptr->oldMan.giddy;
src/mauville_old_man.c:    return gSaveBlock1Ptr->oldMan.common.id;
src/mauville_old_man.c:    gSpecialVar_Result = (&gSaveBlock1Ptr->oldMan.bard)->hasChangedSong;
src/mauville_old_man.c:    struct MauvilleManBard *bard = &gSaveBlock1Ptr->oldMan.bard;
src/mauville_old_man.c:    struct MauvilleManBard *bard = &gSaveBlock1Ptr->oldMan.bard;
src/mauville_old_man.c:    gSpecialVar_Result = (&gSaveBlock1Ptr->oldMan.hipster)->taughtWord;
src/mauville_old_man.c:    (&gSaveBlock1Ptr->oldMan.hipster)->taughtWord = TRUE;
src/mauville_old_man.c:    struct MauvilleManGiddy *giddy = &gSaveBlock1Ptr->oldMan.giddy;
src/mauville_old_man.c:    struct MauvilleManGiddy *giddy = &gSaveBlock1Ptr->oldMan.giddy;
src/mauville_old_man.c:    struct MauvilleManGiddy *giddy = &gSaveBlock1Ptr->oldMan.giddy;
src/mauville_old_man.c:    (&gSaveBlock1Ptr->oldMan.bard)->hasChangedSong = FALSE;
src/mauville_old_man.c:    (&gSaveBlock1Ptr->oldMan.hipster)->taughtWord = FALSE;
src/mauville_old_man.c:        struct MauvilleManBard *bard = &gSaveBlock1Ptr->oldMan.bard;
src/mauville_old_man.c:        struct MauvilleManBard *bard = &gSaveBlock1Ptr->oldMan.bard;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/mauville_old_man.c:    sStorytellerPtr = &gSaveBlock1Ptr->oldMan.storyteller;
src/field_weather_effect.c:    u8 oldWeather = gSaveBlock1Ptr->weather;
src/field_weather_effect.c:    gSaveBlock1Ptr->weather = TranslateWeatherNum(weather);
src/field_weather_effect.c:    UpdateRainCounter(gSaveBlock1Ptr->weather, oldWeather);
src/field_weather_effect.c:    return gSaveBlock1Ptr->weather;
src/field_weather_effect.c:    u8 oldWeather = gSaveBlock1Ptr->weather;
src/field_weather_effect.c:    gSaveBlock1Ptr->weather = TranslateWeatherNum(gMapHeader.weather);
src/field_weather_effect.c:    UpdateRainCounter(gSaveBlock1Ptr->weather, oldWeather);
src/field_weather_effect.c:    case WEATHER_ROUTE119_CYCLE:     return sWeatherCycleRoute119[gSaveBlock1Ptr->weatherCycleStage];
src/field_weather_effect.c:    case WEATHER_ROUTE123_CYCLE:     return sWeatherCycleRoute123[gSaveBlock1Ptr->weatherCycleStage];
src/field_weather_effect.c:    u16 weatherStage = gSaveBlock1Ptr->weatherCycleStage + increment;
src/field_weather_effect.c:    gSaveBlock1Ptr->weatherCycleStage = weatherStage;
src/pokemon_storage_system.c:        || (sRestrictedReleaseMoves[i].mapGroup == gSaveBlock1Ptr->location.mapGroup
src/pokemon_storage_system.c:         && sRestrictedReleaseMoves[i].mapNum == gSaveBlock1Ptr->location.mapNum))
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.iconId = 0;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.patternId = 0;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.patternUnlocked = FALSE;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.colors[0] = RGB(21, 25, 30);
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.colors[1] = RGB(6, 12, 24);
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.text[0] = EOS;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.patternUnlocked = unlocked;
src/pokemon_storage_system.c:    return gSaveBlock1Ptr->waldaPhrase.patternUnlocked;
src/pokemon_storage_system.c:    return gSaveBlock1Ptr->waldaPhrase.patternId;
src/pokemon_storage_system.c:        gSaveBlock1Ptr->waldaPhrase.patternId = id;
src/pokemon_storage_system.c:    return gSaveBlock1Ptr->waldaPhrase.iconId;
src/pokemon_storage_system.c:        gSaveBlock1Ptr->waldaPhrase.iconId = id;
src/pokemon_storage_system.c:    return gSaveBlock1Ptr->waldaPhrase.colors;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.colors[0] = color1;
src/pokemon_storage_system.c:    gSaveBlock1Ptr->waldaPhrase.colors[1] = color2;
src/pokemon_storage_system.c:    return gSaveBlock1Ptr->waldaPhrase.text;
src/pokemon_storage_system.c:    StringCopy(gSaveBlock1Ptr->waldaPhrase.text, src);
src/pokemon_storage_system.c:    return (gSaveBlock1Ptr->waldaPhrase.text[0] == EOS);
src/scrcmd.c:    *pX = gSaveBlock1Ptr->pos.x;
src/scrcmd.c:    *pY = gSaveBlock1Ptr->pos.y;
src/scrcmd.c:    ScriptMovement_StartObjectMovementScript(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, movementScript);
src/scrcmd.c:        ScriptMovement_StartObjectMovementScript(OBJ_EVENT_ID_FOLLOWER, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, EnterPokeballMovement);
src/scrcmd.c:    sMovingNpcMapGroup = gSaveBlock1Ptr->location.mapGroup;
src/scrcmd.c:    sMovingNpcMapNum = gSaveBlock1Ptr->location.mapNum;
src/scrcmd.c:    RemoveObjectEventByLocalIdAndMap(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/scrcmd.c:    TrySpawnObjectEvent(objectId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/scrcmd.c:    TryMoveObjectEventToMapCoords(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, x, y);
src/scrcmd.c:    TryOverrideObjectEventTemplateCoords(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/scrcmd.c:    ObjectEventTurnByLocalIdAndMap(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, direction);
src/scrcmd.c:        AddMoney(&gSaveBlock1Ptr->money, amount);
src/scrcmd.c:        RemoveMoney(&gSaveBlock1Ptr->money, amount);
src/scrcmd.c:        gSpecialVar_Result = IsEnoughMoney(&gSaveBlock1Ptr->money, amount);
src/scrcmd.c:        DrawMoneyBox(GetMoney(&gSaveBlock1Ptr->money), x, y);
src/scrcmd.c:        ChangeAmountInMoneyBox(GetMoney(&gSaveBlock1Ptr->money));
src/link_rfu_3.c:        struct TrainerNameRecord *newRecords = AllocZeroed(sizeof(gSaveBlock1Ptr->trainerNameRecords));
src/link_rfu_3.c:            for (j = 0; j < (int)ARRAY_COUNT(gSaveBlock1Ptr->trainerNameRecords); j++)
src/link_rfu_3.c:                if ((u16)gLinkPlayers[i].trainerId ==  gSaveBlock1Ptr->trainerNameRecords[j].trainerId && StringCompare(gLinkPlayers[i].name, gSaveBlock1Ptr->trainerNameRecords[j].trainerName) == 0)
src/link_rfu_3.c:                    memset(gSaveBlock1Ptr->trainerNameRecords[connectedTrainerRecordIndices[i]].trainerName, 0, PLAYER_NAME_LENGTH + 1);
src/link_rfu_3.c:        for (i = 0; i < (int)ARRAY_COUNT(gSaveBlock1Ptr->trainerNameRecords); i++)
src/link_rfu_3.c:            if (NameIsNotEmpty(gSaveBlock1Ptr->trainerNameRecords[i].trainerName))
src/link_rfu_3.c:                CopyTrainerRecord(&newRecords[nextSpace], gSaveBlock1Ptr->trainerNameRecords[i].trainerId, gSaveBlock1Ptr->trainerNameRecords[i].trainerName);
src/link_rfu_3.c:                if (++nextSpace >= (int)ARRAY_COUNT(gSaveBlock1Ptr->trainerNameRecords))
src/link_rfu_3.c:        memcpy(gSaveBlock1Ptr->trainerNameRecords, newRecords, sizeof(gSaveBlock1Ptr->trainerNameRecords));
src/link_rfu_3.c:    for (i = 0; i < (int)ARRAY_COUNT(gSaveBlock1Ptr->trainerNameRecords); i++)
src/link_rfu_3.c:        if (StringCompare(gSaveBlock1Ptr->trainerNameRecords[i].trainerName, name) == 0 && gSaveBlock1Ptr->trainerNameRecords[i].trainerId == id)
src/link_rfu_3.c:        if (!NameIsNotEmpty(gSaveBlock1Ptr->trainerNameRecords[i].trainerName))
src/link_rfu_3.c:    for (i = 0; i < (int)ARRAY_COUNT(gSaveBlock1Ptr->trainerNameRecords); i++)
src/link_rfu_3.c:        gSaveBlock1Ptr->trainerNameRecords[i].trainerId = 0;
src/link_rfu_3.c:        CpuFill16(0, gSaveBlock1Ptr->trainerNameRecords[i].trainerName, PLAYER_NAME_LENGTH + 1);
src/battle_pyramid.c:    struct ObjectEventTemplate *events = gSaveBlock1Ptr->objectEventTemplates;
src/battle_pyramid.c:    struct ObjectEventTemplate *events = gSaveBlock1Ptr->objectEventTemplates;
src/battle_pyramid.c:            if (GetMonData(&gSaveBlock1Ptr->playerParty[partyIndex], MON_DATA_SPECIES, NULL) == GetMonData(&gPlayerParty[j], MON_DATA_SPECIES, NULL))
src/battle_pyramid.c:                        if (GetMonData(&gSaveBlock1Ptr->playerParty[partyIndex], MON_DATA_MOVE1 + l, NULL) == GetMonData(&gPlayerParty[j], MON_DATA_MOVE1 + k, NULL))
src/battle_pyramid.c:                gSaveBlock1Ptr->playerParty[partyIndex] = gPlayerParty[j];
src/battle_pyramid.c:    gSaveBlock1Ptr->objectEventTemplates[gSpecialVar_LastTalked - 1].movementType = MOVEMENT_TYPE_WANDER_AROUND;
src/battle_pyramid.c:                        gSaveBlock1Ptr->pos.x = (mapLayout->width * (i % PYRAMID_FLOOR_SQUARES_WIDE)) + x;
src/battle_pyramid.c:                        gSaveBlock1Ptr->pos.y = (mapLayout->height * (i / PYRAMID_FLOOR_SQUARES_WIDE)) + y;
src/battle_pyramid.c:    CpuFill32(0, gSaveBlock1Ptr->objectEventTemplates, sizeof(gSaveBlock1Ptr->objectEventTemplates));
src/battle_pyramid.c:    struct ObjectEventTemplate *events = gSaveBlock1Ptr->objectEventTemplates;
src/battle_pyramid.c:    struct ObjectEventTemplate *floorEvents = gSaveBlock1Ptr->objectEventTemplates;
src/battle_pyramid.c:    struct ObjectEventTemplate *events = gSaveBlock1Ptr->objectEventTemplates;
src/party_menu.c:        gSaveBlock1Ptr->mail[mail].words,
src/party_menu.c:    ReadMail(&gSaveBlock1Ptr->mail[GetMonData(&gPlayerParty[gPartyMenu.slotId], MON_DATA_MAIL)], CB2_ReturnToPartyMenuFromReadingMail, TRUE);
src/party_menu.c:                mapHeader = Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->lastHealLocation.mapGroup, gSaveBlock1Ptr->lastHealLocation.mapNum);
src/party_menu.c:                mapHeader = Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->escapeWarp.mapGroup, gSaveBlock1Ptr->escapeWarp.mapNum);
src/party_menu.c:        gSaveBlock1Ptr->mail[mail].words,
src/party_menu.c:    mail = &gSaveBlock1Ptr->mail[gPlayerPCItemPageInfo.itemsAbove + PARTY_SIZE + gPlayerPCItemPageInfo.cursorPos];
src/party_menu.c:        || (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(BATTLE_FRONTIER_BATTLE_PYRAMID_LOBBY)
src/party_menu.c:            && gSaveBlock1Ptr->location.mapNum == MAP_NUM(BATTLE_FRONTIER_BATTLE_PYRAMID_LOBBY)
src/menu_helpers.c:     && ((gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(TRADE_CENTER)
src/menu_helpers.c:       && gSaveBlock1Ptr->location.mapNum == MAP_NUM(TRADE_CENTER))
src/money.c:    return IsEnoughMoney(&gSaveBlock1Ptr->money, gSpecialVar_0x8005);
src/money.c:    RemoveMoney(&gSaveBlock1Ptr->money, gSpecialVar_0x8005);
src/contest_util.c:        SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/contest_util.c:    gSaveBlock1Ptr->vars[VAR_OBJ_GFX_ID_0 - VARS_START] = gContestMons[0].trainerGfxId;
src/contest_util.c:    gSaveBlock1Ptr->vars[VAR_OBJ_GFX_ID_1 - VARS_START] = gContestMons[1].trainerGfxId;
src/contest_util.c:    gSaveBlock1Ptr->vars[VAR_OBJ_GFX_ID_2 - VARS_START] = gContestMons[2].trainerGfxId;
src/contest_util.c:    if (gSaveBlock1Ptr->contestWinners[contestWinner].species == SPECIES_NONE)
src/contest_util.c:        if (gSaveBlock1Ptr->contestWinners[MUSEUM_CONTEST_WINNERS_START + i].species)
src/contest_util.c:            objectEventId = GetObjectEventIdByLocalIdAndMap(sContestantLocalIds[i], gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/pokeblock_feed.c:    u8 colorId = GetPokeblockData(&gSaveBlock1Ptr->pokeblocks[pokeblockCaseId], PBLOCK_COLOR);
src/pokeblock_feed.c:    struct Pokeblock *pokeblock = &gSaveBlock1Ptr->pokeblocks[gSpecialVar_ItemId];
src/player_pc.c:    ClearItemSlots(gSaveBlock1Ptr->pcItems, PC_ITEMS_COUNT);
src/player_pc.c:        if (gSaveBlock1Ptr->mail[i].itemId != ITEM_NONE)
src/player_pc.c:            if (gSaveBlock1Ptr->mail[i].itemId == ITEM_NONE)
src/player_pc.c:                SWAP(gSaveBlock1Ptr->mail[i], gSaveBlock1Ptr->mail[j], temp);
src/player_pc.c:    StringCopy(gStringVar1, gSaveBlock1Ptr->mail[gPlayerPCItemPageInfo.itemsAbove + PARTY_SIZE + gPlayerPCItemPageInfo.cursorPos].playerName);
src/player_pc.c:        ReadMail(&gSaveBlock1Ptr->mail[gPlayerPCItemPageInfo.itemsAbove + PARTY_SIZE + gPlayerPCItemPageInfo.cursorPos], Mailbox_ReturnToFieldFromReadMail, TRUE);
src/player_pc.c:    struct Mail *mail = &gSaveBlock1Ptr->mail[gPlayerPCItemPageInfo.itemsAbove + PARTY_SIZE + gPlayerPCItemPageInfo.cursorPos];
src/player_pc.c:        CopyItemName_PlayerPC(&sItemStorageMenu->itemNames[i][0], gSaveBlock1Ptr->pcItems[i].itemId);
src/player_pc.c:            ItemStorage_DrawItemIcon(gSaveBlock1Ptr->pcItems[id].itemId);
src/player_pc.c:        ConvertIntToDecimalStringN(gStringVar1, gSaveBlock1Ptr->pcItems[id].quantity, STR_CONV_MODE_RIGHT_ALIGN, 3);
src/player_pc.c:        description = (u8 *)ItemId_GetDescription(gSaveBlock1Ptr->pcItems[id].itemId);
src/player_pc.c:    SetItemListPerPageCount(gSaveBlock1Ptr->pcItems, PC_ITEMS_COUNT, &gPlayerPCItemPageInfo.pageItems, &gPlayerPCItemPageInfo.count, 8);
src/player_pc.c:    CopyItemName(gSaveBlock1Ptr->pcItems[sItemStorageMenu->toSwapPos].itemId, gStringVar1);
src/player_pc.c:        MoveItemSlotInList(gSaveBlock1Ptr->pcItems, sItemStorageMenu->toSwapPos, newPos);
src/player_pc.c:        if (gSaveBlock1Ptr->pcItems[pos].quantity == 1)
src/player_pc.c:        end = CopyItemNameHandlePlural(gSaveBlock1Ptr->pcItems[pos].itemId, gStringVar1, 2);
src/player_pc.c:        if (gSaveBlock1Ptr->pcItems[pos].quantity == 1)
src/player_pc.c:        end = CopyItemNameHandlePlural(gSaveBlock1Ptr->pcItems[pos].itemId, gStringVar1, 2);
src/player_pc.c:    if (AdjustQuantityAccordingToDPadInput(&tQuantity, gSaveBlock1Ptr->pcItems[pos].quantity) == TRUE)
src/player_pc.c:            ItemStorage_PrintMessage(ItemStorage_GetMessage(gSaveBlock1Ptr->pcItems[pos].itemId));
src/player_pc.c:    if (AddBagItem(gSaveBlock1Ptr->pcItems[pos].itemId, tQuantity) == TRUE)
src/player_pc.c:        u8 *end = CopyItemNameHandlePlural(gSaveBlock1Ptr->pcItems[pos].itemId, gStringVar1, tQuantity);
src/player_pc.c:    if (!ItemId_GetImportance(gSaveBlock1Ptr->pcItems[pos].itemId))
src/player_pc.c:        u8 *end = CopyItemNameHandlePlural(gSaveBlock1Ptr->pcItems[pos].itemId, gStringVar1, tQuantity);
src/player_pc.c:    ItemStorage_PrintMessage(ItemStorage_GetMessage(gSaveBlock1Ptr->pcItems[gPlayerPCItemPageInfo.itemsAbove + gPlayerPCItemPageInfo.cursorPos].itemId));
src/player_pc.c:        ItemStorage_PrintMessage(ItemStorage_GetMessage(gSaveBlock1Ptr->pcItems[gPlayerPCItemPageInfo.itemsAbove + gPlayerPCItemPageInfo.cursorPos].itemId));
src/pokenav_menu_handler_gfx.c:            && gSaveBlock1Ptr->trainerRematches[i])
src/battle_palace.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/union_room.c:        memcpy(gBlockSendBuffer, gSaveBlock1Ptr->mail, sizeof(struct Mail) * PARTY_SIZE + 4);
src/union_room.c:    SetWarpDestination(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE, x, y);
src/union_room.c:    SetDynamicWarpWithCoords(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE, x, y);
src/union_room.c:    return gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(UNION_ROOM)
src/union_room.c:        && gSaveBlock1Ptr->location.mapNum == MAP_NUM(UNION_ROOM)
src/item_menu.c:            if (gSaveBlock1Ptr->registeredItem != ITEM_NONE && gSaveBlock1Ptr->registeredItem == itemId)
src/item_menu.c:                if (gSaveBlock1Ptr->registeredItem == gSpecialVar_ItemId)
src/item_menu.c:    if (gSaveBlock1Ptr->registeredItem == gSpecialVar_ItemId)
src/item_menu.c:        gSaveBlock1Ptr->registeredItem = ITEM_NONE;
src/item_menu.c:        gSaveBlock1Ptr->registeredItem = gSpecialVar_ItemId;
src/item_menu.c:    if (gSaveBlock1Ptr->registeredItem != ITEM_NONE)
src/item_menu.c:        if (CheckBagHasItem(gSaveBlock1Ptr->registeredItem, 1) == TRUE)
src/item_menu.c:            gSpecialVar_ItemId = gSaveBlock1Ptr->registeredItem;
src/item_menu.c:            taskId = CreateTask(ItemId_GetFieldFunc(gSaveBlock1Ptr->registeredItem), 8);
src/item_menu.c:            gSaveBlock1Ptr->registeredItem = ITEM_NONE;
src/item_menu.c:    AddMoney(&gSaveBlock1Ptr->money, (ItemId_GetPrice(gSpecialVar_ItemId) / ITEM_SELL_FACTOR) * tItemCount);
src/item_menu.c:    PrintMoneyAmountInMoneyBox(gBagMenu->windowIds[ITEMWIN_MONEY], GetMoney(&gSaveBlock1Ptr->money), 0);
src/item_menu.c:    memcpy(sTempWallyBag->bagPocket_Items, gSaveBlock1Ptr->bagPocket_Items, sizeof(gSaveBlock1Ptr->bagPocket_Items));
src/item_menu.c:    memcpy(sTempWallyBag->bagPocket_PokeBalls, gSaveBlock1Ptr->bagPocket_PokeBalls, sizeof(gSaveBlock1Ptr->bagPocket_PokeBalls));
src/item_menu.c:    ClearItemSlots(gSaveBlock1Ptr->bagPocket_Items, BAG_ITEMS_COUNT);
src/item_menu.c:    ClearItemSlots(gSaveBlock1Ptr->bagPocket_PokeBalls, BAG_POKEBALLS_COUNT);
src/item_menu.c:    memcpy(gSaveBlock1Ptr->bagPocket_Items, sTempWallyBag->bagPocket_Items, sizeof(sTempWallyBag->bagPocket_Items));
src/item_menu.c:    memcpy(gSaveBlock1Ptr->bagPocket_PokeBalls, sTempWallyBag->bagPocket_PokeBalls, sizeof(sTempWallyBag->bagPocket_PokeBalls));
src/item_menu.c:    PrintMoneyAmountInMoneyBoxWithBorder(windowId, 1, 14, GetMoney(&gSaveBlock1Ptr->money));
src/menu_specialized.c:    StringCopy(buffer, gSaveBlock1Ptr->mail[PARTY_SIZE + itemId].playerName);
src/field_control_avatar.c:            SetDynamicWarp(mapHeader->events->warps[warpEventId].warpId, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, warpEventId);
src/field_specials.c:        x = gSaveBlock1Ptr->pos.x - 1;
src/field_specials.c:        y = gSaveBlock1Ptr->pos.y;
src/field_specials.c:        x = gSaveBlock1Ptr->pos.x;
src/field_specials.c:        y = gSaveBlock1Ptr->pos.y - 1;
src/field_specials.c:        x = gSaveBlock1Ptr->pos.x + 1;
src/field_specials.c:        y = gSaveBlock1Ptr->pos.y;
src/field_specials.c:        x = gSaveBlock1Ptr->pos.x;
src/field_specials.c:        y = gSaveBlock1Ptr->pos.y + 1;
src/field_specials.c:        u8 obj = GetObjectEventIdByLocalIdAndMap(localEventId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/field_specials.c:    gSpecialVar_0x8004 = gSaveBlock1Ptr->pos.x;
src/field_specials.c:    gSpecialVar_0x8005 = gSaveBlock1Ptr->pos.y;
src/field_specials.c:    MapGridSetMetatileIdAt(gSaveBlock1Ptr->pos.x + dx + MAP_OFFSET, gSaveBlock1Ptr->pos.y + dy + MAP_OFFSET, metatileId | MAPGRID_COLLISION_MASK);
src/field_specials.c:    MapGridSetMetatileIdAt(gSaveBlock1Ptr->pos.x + dx + MAP_OFFSET, gSaveBlock1Ptr->pos.y + dy + MAP_OFFSET, metatileId | MAPGRID_COLLISION_MASK);
src/field_specials.c:                                                  gSaveBlock1Ptr->pos.x + MAP_OFFSET,
src/field_specials.c:                                                  gSaveBlock1Ptr->pos.y + MAP_OFFSET,
src/field_specials.c:    RemoveObjectEventByLocalIdAndMap(OBJ_EVENT_ID_CAMERA, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/field_specials.c:    u32 rnd = gSaveBlock1Ptr->dewfordTrends[0].trendiness + gSaveBlock1Ptr->dewfordTrends[0].rand + sSlotMachineRandomSeeds[gSpecialVar_0x8004];
src/field_specials.c:        && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(RUSTURF_TUNNEL)
src/field_specials.c:        && gSaveBlock1Ptr->location.mapNum == MAP_NUM(RUSTURF_TUNNEL))
src/field_specials.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(BATTLE_FRONTIER_BATTLE_TOWER_MULTI_PARTNER_ROOM)
src/field_specials.c:        && gSaveBlock1Ptr->location.mapNum == MAP_NUM(BATTLE_FRONTIER_BATTLE_TOWER_MULTI_PARTNER_ROOM) &&
src/field_specials.c:    switch (gSaveBlock1Ptr->dynamicWarp.mapNum)
src/field_specials.c:    if (gSaveBlock1Ptr->dynamicWarp.mapGroup == MAP_GROUP(LILYCOVE_CITY_DEPARTMENT_STORE_1F))
src/field_specials.c:        switch (gSaveBlock1Ptr->dynamicWarp.mapNum)
src/field_specials.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(TRAINER_HILL_ENTRANCE) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(TRAINER_HILL_ENTRANCE))
src/field_specials.c:    if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(BIRTH_ISLAND_EXTERIOR) && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(BIRTH_ISLAND_EXTERIOR))
src/field_specials.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(UNDERWATER_MARINE_CAVE))
src/field_specials.c:            switch (gSaveBlock1Ptr->location.mapNum)
src/field_specials.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(UNDERWATER_ROUTE127))
src/field_specials.c:            switch (gSaveBlock1Ptr->location.mapNum)
src/field_specials.c:        if (gSaveBlock1Ptr->location.mapNum == sAbnormalWeatherMapNumbers[abnormalWeather - 1] &&
src/field_specials.c:            gSaveBlock1Ptr->location.mapGroup == 0)
src/field_specials.c:        if (gSaveBlock1Ptr->location.mapGroup == sPokeMarts[i][0])
src/field_specials.c:            if (gSaveBlock1Ptr->location.mapNum == sPokeMarts[i][1])
src/field_specials.c:                MapGridSetMetatileIdAt(gSaveBlock1Ptr->pos.x + x + MAP_OFFSET - 1,
src/field_specials.c:                                       gSaveBlock1Ptr->pos.y + y + MAP_OFFSET - 3,
src/field_specials.c:    if (gSaveBlock1Ptr->lastHealLocation.mapGroup == MAP_GROUP(DEWFORD_TOWN) && gSaveBlock1Ptr->lastHealLocation.mapNum == MAP_NUM(DEWFORD_TOWN))
src/field_specials.c:    u16 map = (gSaveBlock1Ptr->location.mapGroup << 8) + gSaveBlock1Ptr->location.mapNum;
src/field_specials.c:#define FANCLUB_BITFIELD (gSaveBlock1Ptr->vars[VAR_FANCLUB_FAN_COUNTER - VARS_START])
src/field_specials.c:    gSaveBlock1Ptr->vars[VAR_FANCLUB_FAN_COUNTER - VARS_START] = 0;
src/field_specials.c:    gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] = 0;
src/field_specials.c:        gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] = gSaveBlock2Ptr->playTimeHours;
src/field_specials.c:        gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] = gSaveBlock2Ptr->playTimeHours;
src/field_specials.c:                gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] = gSaveBlock2Ptr->playTimeHours;
src/field_specials.c:            else if (gSaveBlock2Ptr->playTimeHours - gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] < 12)
src/field_specials.c:            gSaveBlock1Ptr->vars[VAR_FANCLUB_LOSE_FAN_TIMER - VARS_START] += 12;
src/field_specials.c:    BufferFanClubTrainerName_(&gSaveBlock1Ptr->linkBattleRecords, whichLinkTrainer, whichNPCTrainer);
src/field_specials.c:        const struct ObjectEventTemplate *objTemplate = FindObjectEventTemplateByLocalId(localId, gSaveBlock1Ptr->objectEventTemplates, gMapHeader.events->objectEventCount);
src/field_specials.c:	mapGroup = gSaveBlock1Ptr->location.mapGroup;
src/field_specials.c:	mapNum = gSaveBlock1Ptr->location.mapNum;
src/union_room_chat.c:        StringCopy(chat->registeredTexts[i], gSaveBlock1Ptr->registeredTexts[i]);
src/union_room_chat.c:        StringCopy(gSaveBlock1Ptr->registeredTexts[i], sChat->registeredTexts[i]);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[0], gText_Hello);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[1], gText_Pokemon2);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[2], gText_Trade);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[3], gText_Battle);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[4], gText_Lets);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[5], gText_Ok);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[6], gText_Sorry);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[7], gText_YaySmileEmoji);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[8], gText_ThankYou);
src/union_room_chat.c:    StringCopy(gSaveBlock1Ptr->registeredTexts[9], gText_ByeBye);
src/item_use.c:    u16 mapGroup = gSaveBlock1Ptr->location.mapGroup;
src/item_use.c:    u16 mapNum = gSaveBlock1Ptr->location.mapNum;
src/battle_tower.c:    SetDynamicWarp(0, gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE);
src/battle_tower.c:            u16 itemBefore = GetMonData(&gSaveBlock1Ptr->playerParty[i], MON_DATA_HELD_ITEM);
src/battle_tower.c:                gSaveBlock1Ptr->playerParty[i] = gPlayerParty[i];
src/battle_tower.c:            SetMonData(&gSaveBlock1Ptr->playerParty[i], MON_DATA_HELD_ITEM, &itemBefore);
src/battle_tower.c:        playerRecord->greeting[i] = gSaveBlock1Ptr->easyChatBattleStart[i];
src/battle_tower.c:        playerRecord->speechWon[i] = gSaveBlock1Ptr->easyChatBattleWon[i];
src/battle_tower.c:        playerRecord->speechLost[i] = gSaveBlock1Ptr->easyChatBattleLost[i];
src/battle_tower.c:    objEventTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/battle_tower.c:            if (!GetMonData(&gSaveBlock1Ptr->playerParty[partyIndex], ribbonType))
src/battle_tower.c:                SetMonData(&gSaveBlock1Ptr->playerParty[partyIndex], ribbonType, &gSpecialVar_Result);
src/battle_tower.c:                ribbons[i].count = GetRibbonCount(&gSaveBlock1Ptr->playerParty[partyIndex]);
src/battle_tower.c:            TryPutSpotTheCutiesOnAir(&gSaveBlock1Ptr->playerParty[ribbons[0].partyIndex], ribbonType);
src/battle_tower.c:        ereaderTrainer->greeting[i] = gSaveBlock1Ptr->easyChatBattleStart[i];
src/easy_chat.c:        words = gSaveBlock1Ptr->easyChatProfile;
src/easy_chat.c:        words = gSaveBlock1Ptr->easyChatBattleStart;
src/easy_chat.c:        words = gSaveBlock1Ptr->easyChatBattleWon;
src/easy_chat.c:        words = gSaveBlock1Ptr->easyChatBattleLost;
src/easy_chat.c:        words = gSaveBlock1Ptr->mail[gSpecialVar_0x8005].words;
src/easy_chat.c:        bard = &gSaveBlock1Ptr->oldMan.bard;
src/easy_chat.c:        words = gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].bravoTrainer.words;
src/easy_chat.c:        words = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].fanclubOpinions.words[gSpecialVar_0x8006];
src/easy_chat.c:        words = gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].dummy.words;
src/easy_chat.c:        words[0] = gSaveBlock1Ptr->dewfordTrends[0].words[0];
src/easy_chat.c:        words[1] = gSaveBlock1Ptr->dewfordTrends[0].words[1];
src/easy_chat.c:        words = gSaveBlock1Ptr->gabbyAndTyData.quote;
src/easy_chat.c:        words = &gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].bravoTrainer.words[gSpecialVar_0x8006];
src/easy_chat.c:        words = gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].bravoTrainerTower.words;
src/easy_chat.c:        words = gSaveBlock1Ptr->tvShows[gSpecialVar_0x8005].fanClubSpecial.words;
src/easy_chat.c:        words = &gSaveBlock1Ptr->lilycoveLady.quiz.playerAnswer;
src/easy_chat.c:        words = gSaveBlock1Ptr->lilycoveLady.quiz.question;
src/easy_chat.c:        words = &gSaveBlock1Ptr->lilycoveLady.quiz.correctAnswer;
src/easy_chat.c:            lilycoveLady = &gSaveBlock1Ptr->lilycoveLady;
src/easy_chat.c:        &gSaveBlock1Ptr->lilycoveLady.quiz.playerAnswer,
src/easy_chat.c:        gSaveBlock1Ptr->lilycoveLady.quiz.question,
src/easy_chat.c:        &gSaveBlock1Ptr->lilycoveLady.quiz.correctAnswer,
src/easy_chat.c:        gSaveBlock1Ptr->lilycoveLady.quiz.question,
src/easy_chat.c:    quiz = &gSaveBlock1Ptr->lilycoveLady.quiz;
src/easy_chat.c:        easyChatWords = gSaveBlock1Ptr->easyChatProfile;
src/easy_chat.c:        easyChatWords = gSaveBlock1Ptr->easyChatBattleStart;
src/easy_chat.c:        if (CanPhraseFitInXRowsYCols(gSaveBlock1Ptr->easyChatBattleStart, 3, 2, 18))
src/easy_chat.c:        easyChatWords = gSaveBlock1Ptr->easyChatBattleWon;
src/easy_chat.c:        easyChatWords = gSaveBlock1Ptr->easyChatBattleLost;
src/easy_chat.c:    return (gSaveBlock1Ptr->unlockedTrendySayings[byteOffset] >> shift) & 1;
src/easy_chat.c:        gSaveBlock1Ptr->unlockedTrendySayings[byteOffset] |= 1 << shift;
src/easy_chat.c:        gSaveBlock1Ptr->easyChatProfile[i] = sDefaultProfileWords[i];
src/easy_chat.c:        gSaveBlock1Ptr->easyChatBattleStart[i] = sDefaultBattleStartWords[i];
src/easy_chat.c:        gSaveBlock1Ptr->easyChatBattleWon[i] = sDefaultBattleWonWords[i];
src/easy_chat.c:        gSaveBlock1Ptr->easyChatBattleLost[i] = sDefaultBattleLostWords[i];
src/easy_chat.c:            gSaveBlock1Ptr->mail[i].words[j] = EC_EMPTY_WORD;
src/easy_chat.c:        gSaveBlock1Ptr->unlockedTrendySayings[i] = 0;
src/easy_chat.c:    for (i = 0; i < ARRAY_COUNT(gSaveBlock1Ptr->unlockedTrendySayings); i++)
src/easy_chat.c:        gSaveBlock1Ptr->unlockedTrendySayings[i] = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.bestTime = 0;
src/trainer_hill.c:        SetTimerValue(&gSaveBlock1Ptr->trainerHillTimes[i], HILL_MAX_TIME);
src/trainer_hill.c:    SetTrainerHillVBlankCounter(&gSaveBlock1Ptr->trainerHill.timer);
src/trainer_hill.c:        CpuCopy32(sChallengeData[gSaveBlock1Ptr->trainerHill.mode], &sHillData->challenge, sizeof(sHillData->challenge) + sizeof(sHillData->floors));
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHill.field_3D6E_0f = 1;
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHill.field_3D6E_0f = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.unk_3D6C = 0;
src/trainer_hill.c:    SetTrainerHillVBlankCounter(&gSaveBlock1Ptr->trainerHill.timer);
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.timer = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.spokeToOwner = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.checkedFinalTime = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.maybeECardScanDuringChallenge = 0;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.receivedPrize = 0;
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.spokeToOwner)
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.receivedPrize && gSaveBlock1Ptr->trainerHill.checkedFinalTime)
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.spokeToOwner = TRUE;
src/trainer_hill.c:    if (sHillData->challenge.numFloors != NUM_TRAINER_HILL_FLOORS || gSaveBlock1Ptr->trainerHill.receivedPrize)
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHill.receivedPrize = TRUE;
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.checkedFinalTime)
src/trainer_hill.c:    else if (GetTimerValue(&gSaveBlock1Ptr->trainerHill.bestTime) > gSaveBlock1Ptr->trainerHill.timer)
src/trainer_hill.c:        SetTimerValue(&gSaveBlock1Ptr->trainerHill.bestTime, gSaveBlock1Ptr->trainerHill.timer);
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHillTimes[gSaveBlock1Ptr->trainerHill.mode] = gSaveBlock1Ptr->trainerHill.bestTime;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.checkedFinalTime = TRUE;
src/trainer_hill.c:    if (!gSaveBlock1Ptr->trainerHill.spokeToOwner)
src/trainer_hill.c:        if (gSaveBlock1Ptr->trainerHill.timer >= HILL_MAX_TIME)
src/trainer_hill.c:            gSaveBlock1Ptr->trainerHill.timer = HILL_MAX_TIME;
src/trainer_hill.c:            SetTrainerHillVBlankCounter(&gSaveBlock1Ptr->trainerHill.timer);
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.hasLost = TRUE;
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.hasLost)
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHill.hasLost = FALSE;
src/trainer_hill.c:    else if (gSaveBlock1Ptr->trainerHill.maybeECardScanDuringChallenge)
src/trainer_hill.c:        gSaveBlock1Ptr->trainerHill.maybeECardScanDuringChallenge = 0;
src/trainer_hill.c:    total = gSaveBlock1Ptr->trainerHill.timer;
src/trainer_hill.c:    else if (gSaveBlock1Ptr->trainerHill.spokeToOwner)
src/trainer_hill.c:        total = GetTimerValue(&gSaveBlock1Ptr->trainerHillTimes[i]);
src/trainer_hill.c:    struct ObjectEventTemplate *eventTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/trainer_hill.c:    CpuFill32(0, gSaveBlock1Ptr->objectEventTemplates, sizeof(gSaveBlock1Ptr->objectEventTemplates));
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.hasLost)
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.mode = gSpecialVar_0x8005;
src/trainer_hill.c:    gSaveBlock1Ptr->trainerHill.bestTime = gSaveBlock1Ptr->trainerHillTimes[gSpecialVar_0x8005];
src/trainer_hill.c:    if (gSaveBlock1Ptr->trainerHill.mode == HILL_MODE_EXPERT)
src/trainer_hill.c:    minutes = (signed)(gSaveBlock1Ptr->trainerHill.timer) / (60 * 60);
src/frontier_pass.c:        s8 mapNum = gSaveBlock1Ptr->location.mapNum;
src/frontier_pass.c:            x += gSaveBlock1Ptr->pos.x;
src/frontier_pass.c:            y = gSaveBlock1Ptr->pos.y;
src/frontier_pass.c:                if (gSaveBlock1Ptr->escapeWarp.mapNum == MAP_NUM(BATTLE_FRONTIER_OUTSIDE_EAST))
src/frontier_pass.c:                    x = gSaveBlock1Ptr->escapeWarp.x + 55;
src/frontier_pass.c:                    x = gSaveBlock1Ptr->escapeWarp.x;
src/frontier_pass.c:                y = gSaveBlock1Ptr->escapeWarp.y;
src/debug.c:    memset(&gSaveBlock1Ptr->dexCaught, 0, sizeof(gSaveBlock1Ptr->dexCaught));
src/debug.c:    memset(&gSaveBlock1Ptr->dexSeen, 0, sizeof(gSaveBlock1Ptr->dexSeen));
src/debug.c:    SetMoney(&gSaveBlock1Ptr->money, MAX_MONEY);
src/debug.c:    s32 emptySlot = Daycare_FindEmptySpot(&gSaveBlock1Ptr->daycare);
src/debug.c:    else if (GetDaycareCompatibilityScore(&gSaveBlock1Ptr->daycare) == PARENTS_INCOMPATIBLE) // not compatible parents
src/debug.c:            SetBerryTreeJustPicked(gObjectEvents[i].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/debug.c:            tree = &gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(i)];
src/debug.c:            tree = &gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(i)];
src/debug.c:            if (gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(i)].stage != BERRY_STAGE_PLANTED)
src/debug.c:                gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(i)].pests = TRUE;
src/debug.c:            gSaveBlock1Ptr->berryTrees[GetObjectEventBerryTreeId(i)].weeds = TRUE;
src/fieldmap.c:    mapView = gSaveBlock1Ptr->mapView;
src/fieldmap.c:    x = gSaveBlock1Ptr->pos.x;
src/fieldmap.c:    y = gSaveBlock1Ptr->pos.y;
src/fieldmap.c:        marker |= gSaveBlock1Ptr->mapView[i];
src/fieldmap.c:    for (i = 0; i < ARRAY_COUNT(gSaveBlock1Ptr->mapView); i++)
src/fieldmap.c:        marker |= gSaveBlock1Ptr->mapView[i];
src/fieldmap.c:    CpuFill16(0, gSaveBlock1Ptr->mapView, sizeof(gSaveBlock1Ptr->mapView));
src/fieldmap.c:    mapView = gSaveBlock1Ptr->mapView;
src/fieldmap.c:        x = gSaveBlock1Ptr->pos.x;
src/fieldmap.c:        y = gSaveBlock1Ptr->pos.y;
src/fieldmap.c:    mapView = gSaveBlock1Ptr->mapView;
src/fieldmap.c:    x0 = gSaveBlock1Ptr->pos.x;
src/fieldmap.c:    y0 = gSaveBlock1Ptr->pos.y;
src/fieldmap.c:    return GetMapBorderIdAt(gSaveBlock1Ptr->pos.x + MAP_OFFSET + x, gSaveBlock1Ptr->pos.y + MAP_OFFSET + y);
src/fieldmap.c:    x = gSaveBlock1Ptr->pos.x + MAP_OFFSET + gDirectionToVectors[direction].x;
src/fieldmap.c:    y = gSaveBlock1Ptr->pos.y + MAP_OFFSET + gDirectionToVectors[direction].y;
src/fieldmap.c:        gSaveBlock1Ptr->pos.x = -x;
src/fieldmap.c:        gSaveBlock1Ptr->pos.y -= connection->offset;
src/fieldmap.c:        gSaveBlock1Ptr->pos.x = mapHeader->mapLayout->width;
src/fieldmap.c:        gSaveBlock1Ptr->pos.y -= connection->offset;
src/fieldmap.c:        gSaveBlock1Ptr->pos.x -= connection->offset;
src/fieldmap.c:        gSaveBlock1Ptr->pos.y = -y;
src/fieldmap.c:        gSaveBlock1Ptr->pos.x -= connection->offset;
src/fieldmap.c:        gSaveBlock1Ptr->pos.y = mapHeader->mapLayout->height;
src/fieldmap.c:        gSaveBlock1Ptr->pos.x += x;
src/fieldmap.c:        gSaveBlock1Ptr->pos.y += y;
src/fieldmap.c:        old_x = gSaveBlock1Ptr->pos.x;
src/fieldmap.c:        old_y = gSaveBlock1Ptr->pos.y;
src/fieldmap.c:        connection = GetIncomingConnection(direction, gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y);
src/fieldmap.c:            gCamera.x = old_x - gSaveBlock1Ptr->pos.x;
src/fieldmap.c:            gCamera.y = old_y - gSaveBlock1Ptr->pos.y;
src/fieldmap.c:            gSaveBlock1Ptr->pos.x += x;
src/fieldmap.c:            gSaveBlock1Ptr->pos.y += y;
src/fieldmap.c:    gSaveBlock1Ptr->pos.x = x - MAP_OFFSET;
src/fieldmap.c:    gSaveBlock1Ptr->pos.y = y - MAP_OFFSET;
src/fieldmap.c:    *x = gSaveBlock1Ptr->pos.x + MAP_OFFSET;
src/fieldmap.c:    *y = gSaveBlock1Ptr->pos.y + MAP_OFFSET;
src/fieldmap.c:    gSaveBlock1Ptr->pos.x = x;
src/fieldmap.c:    gSaveBlock1Ptr->pos.y = y;
src/fieldmap.c:    *x = gSaveBlock1Ptr->pos.x;
src/fieldmap.c:    *y = gSaveBlock1Ptr->pos.y;
src/overworld.c:        SetMoney(&gSaveBlock1Ptr->money, GetMoney(&gSaveBlock1Ptr->money) / 2);
src/overworld.c:    return gSaveBlock1Ptr->gameStats[index] ^ gSaveBlock2Ptr->encryptionKey;
src/overworld.c:        gSaveBlock1Ptr->gameStats[index] = value ^ gSaveBlock2Ptr->encryptionKey;
src/overworld.c:        ApplyNewEncryptionKeyToWord(&gSaveBlock1Ptr->gameStats[i], newKey);
src/overworld.c:    CpuFill32(0, gSaveBlock1Ptr->objectEventTemplates, sizeof(gSaveBlock1Ptr->objectEventTemplates));
src/overworld.c:              gSaveBlock1Ptr->objectEventTemplates,
src/overworld.c:    struct ObjectEventTemplate *savObjTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/overworld.c:    struct ObjectEventTemplate *savObjTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/overworld.c:    struct ObjectEventTemplate *savObjTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/overworld.c:    gLastUsedWarp = gSaveBlock1Ptr->location;
src/overworld.c:    gSaveBlock1Ptr->location = sWarpDestination;
src/overworld.c:    gMapHeader = *Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:    gSaveBlock1Ptr->mapLayoutId = gMapHeader.mapLayoutId;
src/overworld.c:    gMapHeader = *Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:    gMapHeader.mapLayout = GetMapLayout(gSaveBlock1Ptr->mapLayoutId);
src/overworld.c:    if (gSaveBlock1Ptr->location.warpId >= 0 && gSaveBlock1Ptr->location.warpId < gMapHeader.events->warpCount)
src/overworld.c:        gSaveBlock1Ptr->pos.x = gMapHeader.events->warps[gSaveBlock1Ptr->location.warpId].x;
src/overworld.c:        gSaveBlock1Ptr->pos.y = gMapHeader.events->warps[gSaveBlock1Ptr->location.warpId].y;
src/overworld.c:    else if (gSaveBlock1Ptr->location.x >= 0 && gSaveBlock1Ptr->location.y >= 0)
src/overworld.c:        gSaveBlock1Ptr->pos.x = gSaveBlock1Ptr->location.x;
src/overworld.c:        gSaveBlock1Ptr->pos.y = gSaveBlock1Ptr->location.y;
src/overworld.c:        gSaveBlock1Ptr->pos.x = gMapHeader.mapLayout->width / 2;
src/overworld.c:        gSaveBlock1Ptr->pos.y = gMapHeader.mapLayout->height / 2;
src/overworld.c:    SetWarpData(&gSaveBlock1Ptr->dynamicWarp, mapGroup, mapNum, warpId, gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y);
src/overworld.c:    SetWarpData(&gSaveBlock1Ptr->dynamicWarp, mapGroup, mapNum, warpId, x, y);
src/overworld.c:    sWarpDestination = gSaveBlock1Ptr->dynamicWarp;
src/overworld.c:    return GetHealNpcLocalId(GetHealLocationIndexByWarpData(&gSaveBlock1Ptr->lastHealLocation)) > 0;
src/overworld.c:        sWarpDestination = gSaveBlock1Ptr->lastHealLocation;
src/overworld.c:        SetWarpData(&gSaveBlock1Ptr->lastHealLocation, healLocation->group, healLocation->map, WARP_ID_NONE, healLocation->x, healLocation->y);
src/overworld.c:        SetEscapeWarp(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum, WARP_ID_NONE, x - MAP_OFFSET, y - MAP_OFFSET + 1);
src/overworld.c:    SetWarpData(&gSaveBlock1Ptr->escapeWarp, mapGroup, mapNum, warpId, x, y);
src/overworld.c:    sWarpDestination = gSaveBlock1Ptr->escapeWarp;
src/overworld.c:    sWarpDestination = gSaveBlock1Ptr->continueGameWarp;
src/overworld.c:    SetWarpData(&gSaveBlock1Ptr->continueGameWarp, mapGroup, mapNum, warpId, x, y);
src/overworld.c:        SetWarpData(&gSaveBlock1Ptr->continueGameWarp, healLocation->group, healLocation->map, WARP_ID_NONE, healLocation->x, healLocation->y);
src/overworld.c:    gSaveBlock1Ptr->continueGameWarp = gSaveBlock1Ptr->dynamicWarp;
src/overworld.c:	DebugPrintf("\nBefore LoadCurrentMapData\nX: %d\nY: %d\nMAPSEC: %d\nMAPNUM: %d", gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y, gMapHeader.regionMapSectionId, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:	DebugPrintf("\nAfter LoadCurrentMapData\nX: %d\nY: %d\nMAPSEC: %d\nMAPNUM: %d", gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y, gMapHeader.regionMapSectionId, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:	DebugPrintf("\nEND\nX: %d\nY: %d\nMAPSEC: %d\nMAPNUM: %d", gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y, gMapHeader.regionMapSectionId, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:    TryUpdateRandomTrainerRematches(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:     MapResetTrainerRematches(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum);
src/overworld.c:    return MapGridGetMetatileBehaviorAt(gSaveBlock1Ptr->pos.x + MAP_OFFSET, gSaveBlock1Ptr->pos.y + MAP_OFFSET);
src/overworld.c:        gSaveBlock1Ptr->flashLevel = 0;
src/overworld.c:        gSaveBlock1Ptr->flashLevel = 1;
src/overworld.c:        gSaveBlock1Ptr->flashLevel = gMaxFlashLevel - 1;
src/overworld.c:    gSaveBlock1Ptr->flashLevel = flashLevel;
src/overworld.c:    return gSaveBlock1Ptr->flashLevel;
src/overworld.c:    gSaveBlock1Ptr->mapLayoutId = mapLayoutId;
src/overworld.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE111)
src/overworld.c:     && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE111)
src/overworld.c:    music = GetLocationMusic(&gSaveBlock1Ptr->location);
src/overworld.c:        if (gSaveBlock1Ptr->pos.x < 24)
src/overworld.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(MAUVILLE_CITY)
src/overworld.c:         && gSaveBlock1Ptr->location.mapNum == MAP_NUM(MAUVILLE_CITY))
src/overworld.c:        if (gSaveBlock1Ptr->savedMusic)
src/overworld.c:            music = gSaveBlock1Ptr->savedMusic;
src/overworld.c:    gSaveBlock1Ptr->savedMusic = songNum;
src/overworld.c:    gSaveBlock1Ptr->savedMusic = MUS_DUMMY;
src/overworld.c:            && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(SOOTOPOLIS_CITY)
src/overworld.c:            && gSaveBlock1Ptr->location.mapNum == MAP_NUM(SOOTOPOLIS_CITY)
src/overworld.c:    if ((gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE130)
src/overworld.c:     && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE130))
src/overworld.c:    return GetMapTypeByWarpData(&gSaveBlock1Ptr->location);
src/overworld.c:    return Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->dynamicWarp.mapGroup, gSaveBlock1Ptr->dynamicWarp.mapNum)->regionMapSectionId;
src/overworld.c:    return Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum)->regionMapSectionId;
src/overworld.c:    return Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum)->battleType;
src/overworld.c:	//DebugPrintf("\n=======\nDDMV:\nmapNum: %d\nX: %d\nY: %d\n=======\n", gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y);
src/overworld.c:	if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE3) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE3)) 
src/overworld.c:	if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(MARE_WWW) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(MARE_WWW)) 
src/wild_encounter.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE119)
src/wild_encounter.c:     && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE119))
src/wild_encounter.c:        FeebasSeedRng(gSaveBlock1Ptr->dewfordTrends[0].rand);
src/wild_encounter.c:        if (gWildMonHeaders[i].mapGroup == gSaveBlock1Ptr->location.mapGroup &&
src/wild_encounter.c:            gWildMonHeaders[i].mapNum == gSaveBlock1Ptr->location.mapNum)
src/wild_encounter.c:            if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ALTERING_CAVE) &&
src/wild_encounter.c:                gSaveBlock1Ptr->location.mapNum == MAP_NUM(ALTERING_CAVE))
src/wild_encounter.c:    if (flags & WILD_CHECK_REPEL && !IsWildLevelAllowedByRepel(gSaveBlock1Ptr->outbreakPokemonLevel))
src/wild_encounter.c:    CreateWildMon(gSaveBlock1Ptr->outbreakPokemonSpecies, gSaveBlock1Ptr->outbreakPokemonLevel);
src/wild_encounter.c:        SetMonMoveSlot(&gEnemyParty[0], gSaveBlock1Ptr->outbreakPokemonMoves[i], i);
src/wild_encounter.c:    if (gSaveBlock1Ptr->outbreakPokemonSpecies != SPECIES_NONE
src/wild_encounter.c:     && gSaveBlock1Ptr->location.mapNum == gSaveBlock1Ptr->outbreakLocationMapNum
src/wild_encounter.c:     && gSaveBlock1Ptr->location.mapGroup == gSaveBlock1Ptr->outbreakLocationMapGroup)
src/wild_encounter.c:        if (Random() % 100 < gSaveBlock1Ptr->outbreakPokemonProbability)
src/wild_encounter.c:        else if (ability == ABILITY_SAND_VEIL && gSaveBlock1Ptr->weather == WEATHER_SANDSTORM)
src/wild_encounter.c:        else if (ability == ABILITY_SNOW_CLOAK && gSaveBlock1Ptr->weather == WEATHER_SNOW)
src/wild_encounter.c:    if (gSaveBlock1Ptr->location.mapGroup != MAP_GROUP(SOOTOPOLIS_CITY)
src/wild_encounter.c:     || gSaveBlock1Ptr->location.mapNum != MAP_NUM(SOOTOPOLIS_CITY))
src/wild_encounter.c:                roamer = &gSaveBlock1Ptr->roamer[gEncounteredRoamerIndex];
src/wild_encounter.c:                roamer = &gSaveBlock1Ptr->roamer[gEncounteredRoamerIndex];
src/field_door.c:        if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(BATTLE_FRONTIER_BATTLE_TOWER_MULTI_CORRIDOR)
src/field_door.c:            && gSaveBlock1Ptr->location.mapNum == MAP_NUM(BATTLE_FRONTIER_BATTLE_TOWER_MULTI_CORRIDOR))
src/record_mixing.c:    sSecretBasesSave = gSaveBlock1Ptr->secretBases;
src/record_mixing.c:    sTvShowsSave = gSaveBlock1Ptr->tvShows;
src/record_mixing.c:    sPokeNewsSave = gSaveBlock1Ptr->pokeNews;
src/record_mixing.c:    sOldManSave = &gSaveBlock1Ptr->oldMan;
src/record_mixing.c:    sDewfordTrendsSave = gSaveBlock1Ptr->dewfordTrends;
src/record_mixing.c:    sLilycoveLadySave = &gSaveBlock1Ptr->lilycoveLady;
src/record_mixing.c:    memcpy(&gSaveBlock1Ptr->daycare.mons[0].mail, &mixMail->mail[0], sizeof(struct DaycareMail));
src/record_mixing.c:    memcpy(&gSaveBlock1Ptr->daycare.mons[1].mail, &mixMail->mail[1], sizeof(struct DaycareMail));
src/record_mixing.c:    sRecordMixMail.mail[0] = gSaveBlock1Ptr->daycare.mons[0].mail;
src/record_mixing.c:    sRecordMixMail.mail[1] = gSaveBlock1Ptr->daycare.mons[1].mail;
src/record_mixing.c:    InitDaycareMailRecordMixing(&gSaveBlock1Ptr->daycare, &sRecordMixMail);
src/pokemon_size_record.c:        gSaveBlock1Ptr->giftRibbons[index] = ribbonId;
src/item.c:    gBagPockets[ITEMS_POCKET].itemSlots = gSaveBlock1Ptr->bagPocket_Items;
src/item.c:    gBagPockets[KEYITEMS_POCKET].itemSlots = gSaveBlock1Ptr->bagPocket_KeyItems;
src/item.c:    gBagPockets[BALLS_POCKET].itemSlots = gSaveBlock1Ptr->bagPocket_PokeBalls;
src/item.c:    gBagPockets[TMHM_POCKET].itemSlots = gSaveBlock1Ptr->bagPocket_TMHM;
src/item.c:    gBagPockets[BERRIES_POCKET].itemSlots = gSaveBlock1Ptr->bagPocket_Berries;
src/item.c:        if (gSaveBlock1Ptr->pcItems[i].itemId == ITEM_NONE)
src/item.c:        if (gSaveBlock1Ptr->pcItems[i].itemId != ITEM_NONE)
src/item.c:        if (gSaveBlock1Ptr->pcItems[i].itemId == itemId && GetPCItemQuantity(&gSaveBlock1Ptr->pcItems[i].quantity) >= count)
src/item.c:    newItems = AllocZeroed(sizeof(gSaveBlock1Ptr->pcItems));
src/item.c:    memcpy(newItems, gSaveBlock1Ptr->pcItems, sizeof(gSaveBlock1Ptr->pcItems));
src/item.c:                memcpy(gSaveBlock1Ptr->pcItems, newItems, sizeof(gSaveBlock1Ptr->pcItems));
src/item.c:                memcpy(gSaveBlock1Ptr->pcItems, newItems, sizeof(gSaveBlock1Ptr->pcItems));
src/item.c:    memcpy(gSaveBlock1Ptr->pcItems, newItems, sizeof(gSaveBlock1Ptr->pcItems));
src/item.c:    gSaveBlock1Ptr->pcItems[index].quantity -= count;
src/item.c:    if (gSaveBlock1Ptr->pcItems[index].quantity == 0)
src/item.c:        gSaveBlock1Ptr->pcItems[index].itemId = ITEM_NONE;
src/item.c:            if (gSaveBlock1Ptr->pcItems[i].itemId == 0)
src/item.c:                struct ItemSlot temp = gSaveBlock1Ptr->pcItems[i];
src/item.c:                gSaveBlock1Ptr->pcItems[i] = gSaveBlock1Ptr->pcItems[j];
src/item.c:                gSaveBlock1Ptr->pcItems[j] = temp;
src/item.c:    switch (gSaveBlock1Ptr->registeredItem)
src/item.c:        gSaveBlock1Ptr->registeredItem = ITEM_ACRO_BIKE;
src/item.c:        gSaveBlock1Ptr->registeredItem = ITEM_MACH_BIKE;
src/item.c:        return gSaveBlock1Ptr->enigmaBerry.itemEffect;
src/heal_location.c:    const struct WarpData *warpData = &gSaveBlock1Ptr->lastHealLocation;
src/heal_location.c:    u32 healLocationId = GetHealLocationIndexByWarpData(&gSaveBlock1Ptr->lastHealLocation);
src/heal_location.c:        *(warp) = gSaveBlock1Ptr->lastHealLocation;
src/egg_hatch.c:    return _CheckDaycareMonReceivedMail(&gSaveBlock1Ptr->daycare, gSpecialVar_0x8004);
src/pokedex_area_screen.c:        roamer = &gSaveBlock1Ptr->roamer[i];
src/rotating_tile_puzzle.c:    struct ObjectEventTemplate *objectEvents = gSaveBlock1Ptr->objectEventTemplates;
src/rotating_tile_puzzle.c:            if (GetObjectEventIdByLocalIdAndMap(objectEvents[i].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup) != OBJECT_EVENTS_COUNT)
src/rotating_tile_puzzle.c:                ScriptMovement_StartObjectMovementScript(localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, movementScript);
src/rotating_tile_puzzle.c:    objectEvents = gSaveBlock1Ptr->objectEventTemplates;
src/rotating_tile_puzzle.c:        objectEventId = GetObjectEventIdByLocalIdAndMap(objectEvents[sRotatingTilePuzzle->objects[i].eventTemplateId].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/rotating_tile_puzzle.c:                                                         gSaveBlock1Ptr->location.mapNum,
src/rotating_tile_puzzle.c:                                                         gSaveBlock1Ptr->location.mapGroup,
src/rotating_tile_puzzle.c:                                                         gSaveBlock1Ptr->location.mapNum,
src/rotating_tile_puzzle.c:                                                         gSaveBlock1Ptr->location.mapGroup,
src/rotating_tile_puzzle.c:    struct ObjectEventTemplate *objectEvents = gSaveBlock1Ptr->objectEventTemplates;
src/battle_main.c:            battleBerry->name[i] = gSaveBlock1Ptr->enigmaBerry.berry.name[i];
src/battle_main.c:            battleBerry->itemEffect[i] = gSaveBlock1Ptr->enigmaBerry.itemEffect[i];
src/battle_main.c:        battleBerry->holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/battle_main.c:        battleBerry->holdEffectParam = gSaveBlock1Ptr->enigmaBerry.holdEffectParam;
src/battle_main.c:                gEnigmaBerries[0].name[i] = gSaveBlock1Ptr->enigmaBerry.berry.name[i];
src/battle_main.c:                gEnigmaBerries[2].name[i] = gSaveBlock1Ptr->enigmaBerry.berry.name[i];
src/battle_main.c:                gEnigmaBerries[0].itemEffect[i] = gSaveBlock1Ptr->enigmaBerry.itemEffect[i];
src/battle_main.c:                gEnigmaBerries[2].itemEffect[i] = gSaveBlock1Ptr->enigmaBerry.itemEffect[i];
src/battle_main.c:            gEnigmaBerries[0].holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/battle_main.c:            gEnigmaBerries[2].holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
src/battle_main.c:            gEnigmaBerries[0].holdEffectParam = gSaveBlock1Ptr->enigmaBerry.holdEffectParam;
src/battle_main.c:            gEnigmaBerries[2].holdEffectParam = gSaveBlock1Ptr->enigmaBerry.holdEffectParam;
src/ereader_helpers.c:    return (gSaveBlock1Ptr->trainerHill.unused + 1) % 256;
src/pokenav_match_call_list.c:    return gSaveBlock1Ptr->trainerRematches[index] != 0;
src/pokenav_match_call_list.c:        if (IsRematchEntryRegistered(i) && gSaveBlock1Ptr->trainerRematches[i])
src/pokenav_match_call_list.c:            if (gSaveBlock1Ptr->trainerRematches[index])
src/pokenav_match_call_list.c:            if (!gSaveBlock1Ptr->trainerRematches[state->matchCallEntries[selection].headerId])
src/battle_util2.c:        CreateSecretBaseEnemyParty(&gSaveBlock1Ptr->secretBases[currSecretBaseId]);
src/region_map.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(SS_TIDAL_CORRIDOR)
src/region_map.c:        && (gSaveBlock1Ptr->location.mapNum == MAP_NUM(SS_TIDAL_CORRIDOR)
src/region_map.c:            || gSaveBlock1Ptr->location.mapNum == MAP_NUM(SS_TIDAL_LOWER_DECK)
src/region_map.c:            || gSaveBlock1Ptr->location.mapNum == MAP_NUM(SS_TIDAL_ROOMS)))
src/region_map.c:    switch (GetMapTypeByGroupAndId(gSaveBlock1Ptr->location.mapGroup, gSaveBlock1Ptr->location.mapNum))
src/region_map.c:        x = gSaveBlock1Ptr->pos.x;
src/region_map.c:        y = gSaveBlock1Ptr->pos.y;
src/region_map.c:            mapHeader = Overworld_GetMapHeaderByGroupAndId(gSaveBlock1Ptr->escapeWarp.mapGroup, gSaveBlock1Ptr->escapeWarp.mapNum);
src/region_map.c:            x = gSaveBlock1Ptr->escapeWarp.x;
src/region_map.c:            y = gSaveBlock1Ptr->escapeWarp.y;
src/region_map.c:        mapHeader = Overworld_GetMapHeaderByGroupAndId((u16)gSaveBlock1Ptr->dynamicWarp.mapGroup, (u16)gSaveBlock1Ptr->dynamicWarp.mapNum);
src/region_map.c:        x = gSaveBlock1Ptr->dynamicWarp.x;
src/region_map.c:        y = gSaveBlock1Ptr->dynamicWarp.y;
src/region_map.c:            warp = &gSaveBlock1Ptr->escapeWarp;
src/region_map.c:            warp = &gSaveBlock1Ptr->dynamicWarp;
src/region_map.c:        if (gSaveBlock1Ptr->pos.x > 32)
src/region_map.c:        if (gSaveBlock1Ptr->pos.x > 51)
src/region_map.c:        if (gSaveBlock1Ptr->pos.y > 37)
src/region_map.c:        if (gSaveBlock1Ptr->pos.y > 56)
src/region_map.c:		if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE3) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE3)) 
src/region_map.c:		if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(MARE_WWW) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(MARE_WWW))
src/region_map.c:	x = gSaveBlock1Ptr->pos.x;
src/region_map.c:	y = gSaveBlock1Ptr->pos.y;
src/region_map.c:	x = gSaveBlock1Ptr->pos.x;
src/battle_setup.c:    if (gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(ROUTE113) && gSaveBlock1Ptr->location.mapNum == MAP_NUM(ROUTE113))
src/battle_setup.c:        gSelectedObjectEvent = GetObjectEventIdByLocalIdAndMap(sTrainerObjectEventLocalId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/battle_setup.c:            gSaveBlock1Ptr->playerParty[i] = gPlayerParty[j];
src/battle_setup.c:    gSaveBlock1Ptr->trainerRematches[tableId] = i;
src/battle_setup.c:        if (gSaveBlock1Ptr->trainerRematches[i] != 0)
src/battle_setup.c:        if (table[i].mapGroup == mapGroup && table[i].mapNum == mapNum && gSaveBlock1Ptr->trainerRematches[i] != 0)
src/battle_setup.c:    if (gSaveBlock1Ptr->trainerRematches[tableId] == 0)
src/battle_setup.c:    if (gSaveBlock1Ptr->trainerRematches[tableId] == 0)
src/battle_setup.c:        gSaveBlock1Ptr->trainerRematches[tableId] = 0;
src/battle_setup.c:    if (gSaveBlock1Ptr->trainerRematchStepCounter >= STEP_COUNTER_MAX)
src/battle_setup.c:        gSaveBlock1Ptr->trainerRematchStepCounter = STEP_COUNTER_MAX;
src/battle_setup.c:        gSaveBlock1Ptr->trainerRematchStepCounter++;
src/battle_setup.c:    if (HasAtLeastFiveBadges() && gSaveBlock1Ptr->trainerRematchStepCounter >= STEP_COUNTER_MAX)
src/battle_setup.c:        gSaveBlock1Ptr->trainerRematchStepCounter = 0;
src/contest.c:        gSaveBlock1Ptr->contestWinners[id].personality = gContestMons[i].personality;
src/contest.c:        gSaveBlock1Ptr->contestWinners[id].species = gContestMons[i].species;
src/contest.c:        gSaveBlock1Ptr->contestWinners[id].trainerId = gContestMons[i].otId;
src/contest.c:        StringCopyN(gSaveBlock1Ptr->contestWinners[id].monName, gContestMons[i].nickname, VANILLA_POKEMON_NAME_LENGTH);
src/contest.c:        StringCopy(gSaveBlock1Ptr->contestWinners[id].trainerName, gContestMons[i].trainerName);
src/contest.c:            gSaveBlock1Ptr->contestWinners[id].contestRank = CONTEST_RANK_LINK;
src/contest.c:            gSaveBlock1Ptr->contestWinners[id].contestRank = gSpecialVar_ContestRank;
src/contest.c:            gSaveBlock1Ptr->contestWinners[id].contestCategory = gSpecialVar_ContestCategory;
src/contest.c:            gSaveBlock1Ptr->contestWinners[id].contestCategory = captionId;
src/contest.c:                memcpy(&gSaveBlock1Ptr->contestWinners[i], &gSaveBlock1Ptr->contestWinners[i - 1], sizeof(struct ContestWinner));
src/contest.c:        gSaveBlock1Ptr->contestWinners[i] = gDefaultContestWinners[i];
src/new_game.c:    memset(&gSaveBlock1Ptr->dexCaught, 0, sizeof(gSaveBlock1Ptr->dexCaught));
src/new_game.c:    memset(&gSaveBlock1Ptr->dexSeen, 0, sizeof(gSaveBlock1Ptr->dexSeen));
src/new_game.c:        gSaveBlock1Ptr->contestWinners[i] = sContestWinnerPicDummy;
src/new_game.c:    SetMoney(&gSaveBlock1Ptr->money, 3000);
src/new_game.c:    gSaveBlock1Ptr->registeredItem = ITEM_NONE;
src/field_camera.c:    DrawWholeMapViewInternal(gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y, gMapHeader.mapLayout);
src/field_camera.c:        DrawMetatileAt(mapLayout, r7 + temp, gSaveBlock1Ptr->pos.x + i / 2, gSaveBlock1Ptr->pos.y + 14);
src/field_camera.c:        DrawMetatileAt(mapLayout, r7 + temp, gSaveBlock1Ptr->pos.x + i / 2, gSaveBlock1Ptr->pos.y);
src/field_camera.c:        DrawMetatileAt(mapLayout, temp * 32 + r6, gSaveBlock1Ptr->pos.x, gSaveBlock1Ptr->pos.y + i / 2);
src/field_camera.c:        DrawMetatileAt(mapLayout, temp * 32 + r5, gSaveBlock1Ptr->pos.x + 14, gSaveBlock1Ptr->pos.y + i / 2);
src/field_camera.c:    x -= gSaveBlock1Ptr->pos.x;
src/field_camera.c:    y = (y - gSaveBlock1Ptr->pos.y) * 2;
src/field_camera.c:    s16 deltaX = x - gSaveBlock1Ptr->pos.x;
src/field_camera.c:    s16 deltaY = y - gSaveBlock1Ptr->pos.y;
src/frontier_util.c:            gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[i] - 1] = gPlayerParty[i];
src/frontier_util.c:            u16 item = GetMonData(&gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[i] - 1], MON_DATA_HELD_ITEM, NULL);
src/frontier_util.c:                    if (GetMonData(&gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[i] - 1], MON_DATA_MOVE1 + k, NULL)
src/frontier_util.c:            gSaveBlock1Ptr->playerParty[gSaveBlock2Ptr->frontier.selectedPartyMons[i] - 1] = gPlayerParty[i];
src/mystery_event_script.c:    u8 *data = (u8 *)(&gSaveBlock1Ptr->recordMixingGift.data);
src/mystery_event_script.c:    for (i = 0; i < sizeof(gSaveBlock1Ptr->recordMixingGift.data); i++)
src/mystery_event_script.c:    struct RecordMixingGiftData *data = &gSaveBlock1Ptr->recordMixingGift.data;
src/mystery_event_script.c:        || checksum != gSaveBlock1Ptr->recordMixingGift.checksum)
src/mystery_event_script.c:    CpuFill16(0, &gSaveBlock1Ptr->recordMixingGift, sizeof(gSaveBlock1Ptr->recordMixingGift));
src/mystery_event_script.c:        gSaveBlock1Ptr->recordMixingGift.data.unk0 = unk;
src/mystery_event_script.c:        gSaveBlock1Ptr->recordMixingGift.data.quantity = quantity;
src/mystery_event_script.c:        gSaveBlock1Ptr->recordMixingGift.data.itemId = itemId;
src/mystery_event_script.c:        gSaveBlock1Ptr->recordMixingGift.checksum = CalcRecordMixingGiftChecksum();
src/mystery_event_script.c:    struct RecordMixingGiftData *data = &gSaveBlock1Ptr->recordMixingGift.data;
src/mystery_event_script.c:            gSaveBlock1Ptr->recordMixingGift.checksum = CalcRecordMixingGiftChecksum();
src/mystery_event_script.c:    StringCopyN(gStringVar1, gSaveBlock1Ptr->enigmaBerry.berry.name, BERRY_NAME_LENGTH + 1);
src/mystery_event_script.c:    StringCopyN(gStringVar2, gSaveBlock1Ptr->enigmaBerry.berry.name, BERRY_NAME_LENGTH + 1);
src/pokedex.c:        gSaveBlock1Ptr->dexCaught[i] = 0;
src/pokedex.c:        gSaveBlock1Ptr->dexSeen[i] = 0;
src/pokedex.c:        retVal = ((gSaveBlock1Ptr->dexSeen[index] & mask) != 0);
src/pokedex.c:         retVal = ((gSaveBlock1Ptr->dexCaught[index] & mask) != 0);
src/pokedex.c:        gSaveBlock1Ptr->dexSeen[index] |= mask;
src/pokedex.c:        gSaveBlock1Ptr->dexCaught[index] |= mask;
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_DESK, gSaveBlock1Ptr->decorationDesks);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_CHAIR, gSaveBlock1Ptr->decorationChairs);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_PLANT, gSaveBlock1Ptr->decorationPlants);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_ORNAMENT, gSaveBlock1Ptr->decorationOrnaments);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_MAT, gSaveBlock1Ptr->decorationMats);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_POSTER, gSaveBlock1Ptr->decorationPosters);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_DOLL, gSaveBlock1Ptr->decorationDolls);
src/decoration_inventory.c:    SET_DECOR_INV(DECORCAT_CUSHION, gSaveBlock1Ptr->decorationCushions);
src/pokenav_ribbons_summary.c:        ribbonId = gSaveBlock1Ptr->giftRibbons[ribbonId - FIRST_GIFT_RIBBON];
src/pokenav_match_call_data.c:    return gSaveBlock1Ptr->trainerRematches[matchCall.trainer->rematchTableIdx] ? TRUE : FALSE;
src/pokenav_match_call_data.c:    return gSaveBlock1Ptr->trainerRematches[matchCall.wally->rematchTableIdx] ? TRUE : FALSE;
src/pokenav_match_call_data.c:                if (gSaveBlock1Ptr->trainerRematches[idx])
src/berry_blender.c:    if (gSaveBlock1Ptr->berryBlenderRecords[sBerryBlender->numPlayers - 2] < sBerryBlender->maxRPM)
src/berry_blender.c:        gSaveBlock1Ptr->berryBlenderRecords[sBerryBlender->numPlayers - 2] = sBerryBlender->maxRPM;
src/berry_blender.c:        record = gSaveBlock1Ptr->berryBlenderRecords[i];
src/event_object_movement.c:            template = &gSaveBlock1Ptr->objectEventTemplates[i];
src/event_object_movement.c:                return InitObjectEventStateFromTemplate(template, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup);
src/event_object_movement.c:    return TrySpawnObjectEventTemplate(objectEventTemplate, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, cameraX, cameraY);
src/event_object_movement.c:            .x = gSaveBlock1Ptr->pos.x,
src/event_object_movement.c:            .y = gSaveBlock1Ptr->pos.y,
src/event_object_movement.c:        return (gSaveBlock1Ptr->location.mapGroup == cond->data.bytes[0] &&
src/event_object_movement.c:                gSaveBlock1Ptr->location.mapNum == cond->data.bytes[1]);
src/event_object_movement.c:        s16 left = gSaveBlock1Ptr->pos.x - 2;
src/event_object_movement.c:        s16 right = gSaveBlock1Ptr->pos.x + MAP_OFFSET_W + 2;
src/event_object_movement.c:        s16 top = gSaveBlock1Ptr->pos.y;
src/event_object_movement.c:        s16 bottom = gSaveBlock1Ptr->pos.y + MAP_OFFSET_H + 2;
src/event_object_movement.c:            struct ObjectEventTemplate *template = &gSaveBlock1Ptr->objectEventTemplates[i];
src/event_object_movement.c:                TrySpawnObjectEventTemplate(template, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, cameraX, cameraY);
src/event_object_movement.c:    s16 left =   gSaveBlock1Ptr->pos.x - 2;
src/event_object_movement.c:    s16 right =  gSaveBlock1Ptr->pos.x + 17;
src/event_object_movement.c:    s16 top =    gSaveBlock1Ptr->pos.y;
src/event_object_movement.c:    s16 bottom = gSaveBlock1Ptr->pos.y + 16;
src/event_object_movement.c:    if (gSaveBlock1Ptr->location.mapNum == mapNum && gSaveBlock1Ptr->location.mapGroup == mapGroup)
src/event_object_movement.c:        templates = gSaveBlock1Ptr->objectEventTemplates;
src/event_object_movement.c:    if (objectEvent->mapNum != gSaveBlock1Ptr->location.mapNum
src/event_object_movement.c:     || objectEvent->mapGroup != gSaveBlock1Ptr->location.mapGroup)
src/event_object_movement.c:        if (objectEvent->localId == gSaveBlock1Ptr->objectEventTemplates[i].localId)
src/event_object_movement.c:            return &gSaveBlock1Ptr->objectEventTemplates[i];
src/event_object_movement.c:    *destX = (x - gSaveBlock1Ptr->pos.x) << 4;
src/event_object_movement.c:    *destY = (y - gSaveBlock1Ptr->pos.y) << 4;
src/event_object_movement.c:    *destX = ((mapX - gSaveBlock1Ptr->pos.x) << 4) + dx;
src/event_object_movement.c:    *destY = ((mapY - gSaveBlock1Ptr->pos.y) << 4) + dy;
src/event_object_movement.c:    gFieldEffectArguments[6] = (u8)gSaveBlock1Ptr->location.mapNum << 8 | (u8)gSaveBlock1Ptr->location.mapGroup;
src/event_object_movement.c:    gFieldEffectArguments[6] = (u8)gSaveBlock1Ptr->location.mapNum << 8 | (u8)gSaveBlock1Ptr->location.mapGroup;
src/event_object_movement.c:    gFieldEffectArguments[6] = (u8)gSaveBlock1Ptr->location.mapNum << 8 | (u8)gSaveBlock1Ptr->location.mapGroup;
src/event_object_movement.c:    gFieldEffectArguments[6] = (u8)gSaveBlock1Ptr->location.mapNum << 8 | (u8)gSaveBlock1Ptr->location.mapGroup;
src/event_object_movement.c:	struct ObjectEvent *objectEvent = &gObjectEvents[GetObjectEventIdByLocalIdAndMap(gSpecialVar_0x8005, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup)];
src/event_object_movement.c:        GetMonInfo((struct Pokemon *) &gSaveBlock1Ptr->daycare.mons[i].mon, &specGfx, &form, &shiny);
src/coins.c:    return gSaveBlock1Ptr->coins ^ gSaveBlock2Ptr->encryptionKey;
src/coins.c:    gSaveBlock1Ptr->coins = coinAmount ^ gSaveBlock2Ptr->encryptionKey;
src/safari_zone.c:        if (gSaveBlock1Ptr->location.mapNum == sPokeblockFeeders[i].mapNum
src/safari_zone.c:        if (gSaveBlock1Ptr->location.mapNum == sPokeblockFeeders[i].mapNum)
src/safari_zone.c:            sPokeblockFeeders[i].mapNum = gSaveBlock1Ptr->location.mapNum;
src/safari_zone.c:            sPokeblockFeeders[i].pokeblock = gSaveBlock1Ptr->pokeblocks[pkblId];
src/vs_seeker.c:    struct ObjectEventTemplate * templates = gSaveBlock1Ptr->objectEventTemplates;
src/vs_seeker.c:        TryGetObjectEventIdByLocalIdAndMap(templates[i].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objEventId);
src/vs_seeker.c:        if ((gSaveBlock1Ptr->trainerRematchStepCounter & 0xFF) < VSSEEKER_RECHARGE_STEPS)
src/vs_seeker.c:            gSaveBlock1Ptr->trainerRematchStepCounter++;
src/vs_seeker.c:        if (((gSaveBlock1Ptr->trainerRematchStepCounter >> 8) & 0xFF) < VSSEEKER_RECHARGE_STEPS)
src/vs_seeker.c:            x = (((gSaveBlock1Ptr->trainerRematchStepCounter >> 8) & 0xFF) + 1);
src/vs_seeker.c:            gSaveBlock1Ptr->trainerRematchStepCounter = (gSaveBlock1Ptr->trainerRematchStepCounter & 0xFF) | (x << 8);
src/vs_seeker.c:        if (((gSaveBlock1Ptr->trainerRematchStepCounter >> 8) & 0xFF) == VSSEEKER_RECHARGE_STEPS)
src/vs_seeker.c:    gSaveBlock1Ptr->trainerRematchStepCounter &= 0xFF00;
src/vs_seeker.c:    gSaveBlock1Ptr->trainerRematchStepCounter &= 0x00FF;
src/vs_seeker.c:        ScriptMovement_StartObjectMovementScript(0xFF, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, sMovementScript_Wait48);
src/vs_seeker.c:    struct ObjectEventTemplate *templates = gSaveBlock1Ptr->objectEventTemplates;
src/vs_seeker.c:        TryGetObjectEventIdByLocalIdAndMap(templates[objectEventIdx].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objectEventId);
src/vs_seeker.c:    if (!ScriptMovement_IsObjectMovementFinished(0xFF, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup))
src/vs_seeker.c:    u8 vsSeekerChargeSteps = gSaveBlock1Ptr->trainerRematchStepCounter;
src/vs_seeker.c:                gSaveBlock1Ptr->trainerRematches[VsSeekerConvertLocalIdToTableId(sVsSeeker->trainerInfo[vsSeekerIdx].localId)] = rematchTrainerIdx;
src/vs_seeker.c:    struct ObjectEventTemplate *objectEventTemplates = gSaveBlock1Ptr->objectEventTemplates;
src/vs_seeker.c:        TryGetObjectEventIdByLocalIdAndMap(objectEventTemplates[i].localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objEventId);
src/vs_seeker.c:    for (i = 0; i < ARRAY_COUNT(gSaveBlock1Ptr->trainerRematches); i++)
src/vs_seeker.c:        gSaveBlock1Ptr->trainerRematches[i] = 0;
src/vs_seeker.c:    ScriptMovement_StartObjectMovementScript(trainerInfo->localId, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, script);
src/vs_seeker.c:                gSaveBlock1Ptr->trainerRematches[VsSeekerConvertLocalIdToTableId(sVsSeeker->trainerInfo[j].localId)] = GetRematchTrainerIdFromTable(gRematchTable, sVsSeeker->trainerInfo[j].trainerIdx);
src/battle_records.c:    ClearLinkBattleRecords(gSaveBlock1Ptr->linkBattleRecords.entries);
src/battle_records.c:            &gSaveBlock1Ptr->linkBattleRecords,
src/battle_records.c:    PrintLinkBattleWinsLossesDraws(gSaveBlock1Ptr->linkBattleRecords.entries);
src/battle_records.c:        PrintLinkBattleRecord(&gSaveBlock1Ptr->linkBattleRecords.entries[i], 7 + (i * 2), gSaveBlock1Ptr->linkBattleRecords.languages[i]);
src/faraway_island.c:    TryGetObjectEventIdByLocalIdAndMap(LOCALID_FARAWAY_ISLAND_MEW, gSaveBlock1Ptr->location.mapNum, gSaveBlock1Ptr->location.mapGroup, &objectEventId);
src/faraway_island.c:    if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(FARAWAY_ISLAND_INTERIOR)
src/faraway_island.c:     && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(FARAWAY_ISLAND_INTERIOR))
src/faraway_island.c:    if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(FARAWAY_ISLAND_INTERIOR)
src/faraway_island.c:     && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(FARAWAY_ISLAND_INTERIOR))
src/faraway_island.c:    if (gSaveBlock1Ptr->location.mapNum == MAP_NUM(FARAWAY_ISLAND_INTERIOR)
src/faraway_island.c:     && gSaveBlock1Ptr->location.mapGroup == MAP_GROUP(FARAWAY_ISLAND_INTERIOR))
src/gym_leader_rematch.c:        if (!gSaveBlock1Ptr->trainerRematches[data[i]])
src/gym_leader_rematch.c:            if (!gSaveBlock1Ptr->trainerRematches[data[i]])
src/gym_leader_rematch.c:                if (!gSaveBlock1Ptr->trainerRematches[data[i]])
src/gym_leader_rematch.c:                            gSaveBlock1Ptr->trainerRematches[data[i]] = lowestRematchIndex;
src/field_tasks.c:    mapId = (gSaveBlock1Ptr->location.mapGroup << 8) | gSaveBlock1Ptr->location.mapNum;
